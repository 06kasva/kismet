syntax = "proto2";

package KismetExternal;

// Overall command structure used for all Kismet helper binaries;  Each command
// is an arbitrary string (command type), with a unique sequence number which is
// used in responses to the command.
//
// The payload of the command (content) is arbitrary, however Kismet uses 
// Google Protobuf for all embedded commands, and it strongly recommended that
// other implementations do as well.
// 
// This command is wrapped inside the kismet network structure which defines
// total length, embeds a checksum, and so on.

message Command {
    required string command = 1; // Command type
    required uint32 seqno = 2; // Unique command sequence number
    required bytes content = 3;
}

// Define an endpoint (Helper->Kismet)
// Registers a HTTP endpoint; requests to this endpoint will be sent to the
// helper via the HttpRequest message, which will, in turn, expect replies
// via the HttpResponse message.
message HttpRegisterUri {
    // Full URI, including file type; Helpers cannot take advantage of the Kismet
    // multi-serialization types so they must define a URI for each type
    required string uri = 1;
    // Method; ie GET or POST; a URI can only implement a single method and
    // must register multiple URIs for multiple methods.
    required string method = 2;
}

// Handle an incoming HTTP request (Kismet->Helper)
message HttpRequest {
    // Unique ID of request, must be returned in the HttpResponse
    required uint32 req_id = 1;
    // Full URI of request
    required string uri = 2;
    // Method
    required string method = 3;
    // If post, a map of post variables
    map<string, string> post_data = 4;
}

// Respond to HTTP data (Helper->Kismet)
message HttpResponse {
    // Unique ID of request we're responding to
    required uint32 req_id = 1;
    // Content being sent, if any
    optional bytes content = 2;
    // Result code, if we're concluding this connection
    optional uint32 resultcode = 3;
    // Is this the end of this connection?
    optional bool close_response = 4;
}

// User-readable message (Helper->Kismet)
message MsgbusMessage {
    // Match the Kismet messagebus types
    enum MessageType {
        DEBUG = 1;
        INFO = 2;
        ERROR = 4;
        ALERT = 8;
        FATAL = 16;
    }

    required MessageType msgtype = 1;
    required string msgtext = 2;
}


// Request other end send a PONG (bidirectional)
message Ping {

}

// Respond to PING (bidirectional)
message Pong {
    required uint32 ping_seqno = 1; // PING sequence that reached out to us
}

// Shut down the connection (bidirectional)
message Shutdown {
    required string reason = 1;
}

// Register helper; this helps us identify what we're talking to if we need to
// dispatch the helpers / multiplex over a single TCP socket for remote systems
// (Helper->Kismet)
message SystemRegister {
    required string subsystem = 1;
}

