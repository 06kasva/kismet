// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: kismet.proto

#ifndef PROTOBUF_kismet_2eproto__INCLUDED
#define PROTOBUF_kismet_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace KismetExternal {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_kismet_2eproto();
void protobuf_AssignDesc_kismet_2eproto();
void protobuf_ShutdownFile_kismet_2eproto();

class Command;
class MsgbusMessage;
class Ping;
class Pong;
class Shutdown;
class SystemRegister;

enum MsgbusMessage_MessageType {
  MsgbusMessage_MessageType_DEBUG = 1,
  MsgbusMessage_MessageType_INFO = 2,
  MsgbusMessage_MessageType_ERROR = 4,
  MsgbusMessage_MessageType_ALERT = 8,
  MsgbusMessage_MessageType_FATAL = 16
};
bool MsgbusMessage_MessageType_IsValid(int value);
const MsgbusMessage_MessageType MsgbusMessage_MessageType_MessageType_MIN = MsgbusMessage_MessageType_DEBUG;
const MsgbusMessage_MessageType MsgbusMessage_MessageType_MessageType_MAX = MsgbusMessage_MessageType_FATAL;
const int MsgbusMessage_MessageType_MessageType_ARRAYSIZE = MsgbusMessage_MessageType_MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MsgbusMessage_MessageType_descriptor();
inline const ::std::string& MsgbusMessage_MessageType_Name(MsgbusMessage_MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MsgbusMessage_MessageType_descriptor(), value);
}
inline bool MsgbusMessage_MessageType_Parse(
    const ::std::string& name, MsgbusMessage_MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgbusMessage_MessageType>(
    MsgbusMessage_MessageType_descriptor(), name, value);
}
// ===================================================================

class Command : public ::google::protobuf::Message {
 public:
  Command();
  virtual ~Command();

  Command(const Command& from);

  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Command& default_instance();

  void Swap(Command* other);

  // implements Message ----------------------------------------------

  Command* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Command& from);
  void MergeFrom(const Command& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string command = 1;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 1;
  inline const ::std::string& command() const;
  inline void set_command(const ::std::string& value);
  inline void set_command(const char* value);
  inline void set_command(const char* value, size_t size);
  inline ::std::string* mutable_command();
  inline ::std::string* release_command();
  inline void set_allocated_command(::std::string* command);

  // required uint32 seqno = 2;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 2;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required bytes content = 3;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 3;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const void* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // @@protoc_insertion_point(class_scope:KismetExternal.Command)
 private:
  inline void set_has_command();
  inline void clear_has_command();
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_content();
  inline void clear_has_content();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* command_;
  ::std::string* content_;
  ::google::protobuf::uint32 seqno_;
  friend void  protobuf_AddDesc_kismet_2eproto();
  friend void protobuf_AssignDesc_kismet_2eproto();
  friend void protobuf_ShutdownFile_kismet_2eproto();

  void InitAsDefaultInstance();
  static Command* default_instance_;
};
// -------------------------------------------------------------------

class MsgbusMessage : public ::google::protobuf::Message {
 public:
  MsgbusMessage();
  virtual ~MsgbusMessage();

  MsgbusMessage(const MsgbusMessage& from);

  inline MsgbusMessage& operator=(const MsgbusMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgbusMessage& default_instance();

  void Swap(MsgbusMessage* other);

  // implements Message ----------------------------------------------

  MsgbusMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgbusMessage& from);
  void MergeFrom(const MsgbusMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MsgbusMessage_MessageType MessageType;
  static const MessageType DEBUG = MsgbusMessage_MessageType_DEBUG;
  static const MessageType INFO = MsgbusMessage_MessageType_INFO;
  static const MessageType ERROR = MsgbusMessage_MessageType_ERROR;
  static const MessageType ALERT = MsgbusMessage_MessageType_ALERT;
  static const MessageType FATAL = MsgbusMessage_MessageType_FATAL;
  static inline bool MessageType_IsValid(int value) {
    return MsgbusMessage_MessageType_IsValid(value);
  }
  static const MessageType MessageType_MIN =
    MsgbusMessage_MessageType_MessageType_MIN;
  static const MessageType MessageType_MAX =
    MsgbusMessage_MessageType_MessageType_MAX;
  static const int MessageType_ARRAYSIZE =
    MsgbusMessage_MessageType_MessageType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MessageType_descriptor() {
    return MsgbusMessage_MessageType_descriptor();
  }
  static inline const ::std::string& MessageType_Name(MessageType value) {
    return MsgbusMessage_MessageType_Name(value);
  }
  static inline bool MessageType_Parse(const ::std::string& name,
      MessageType* value) {
    return MsgbusMessage_MessageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .KismetExternal.MsgbusMessage.MessageType msgtype = 1;
  inline bool has_msgtype() const;
  inline void clear_msgtype();
  static const int kMsgtypeFieldNumber = 1;
  inline ::KismetExternal::MsgbusMessage_MessageType msgtype() const;
  inline void set_msgtype(::KismetExternal::MsgbusMessage_MessageType value);

  // required string msgtext = 2;
  inline bool has_msgtext() const;
  inline void clear_msgtext();
  static const int kMsgtextFieldNumber = 2;
  inline const ::std::string& msgtext() const;
  inline void set_msgtext(const ::std::string& value);
  inline void set_msgtext(const char* value);
  inline void set_msgtext(const char* value, size_t size);
  inline ::std::string* mutable_msgtext();
  inline ::std::string* release_msgtext();
  inline void set_allocated_msgtext(::std::string* msgtext);

  // @@protoc_insertion_point(class_scope:KismetExternal.MsgbusMessage)
 private:
  inline void set_has_msgtype();
  inline void clear_has_msgtype();
  inline void set_has_msgtext();
  inline void clear_has_msgtext();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* msgtext_;
  int msgtype_;
  friend void  protobuf_AddDesc_kismet_2eproto();
  friend void protobuf_AssignDesc_kismet_2eproto();
  friend void protobuf_ShutdownFile_kismet_2eproto();

  void InitAsDefaultInstance();
  static MsgbusMessage* default_instance_;
};
// -------------------------------------------------------------------

class Ping : public ::google::protobuf::Message {
 public:
  Ping();
  virtual ~Ping();

  Ping(const Ping& from);

  inline Ping& operator=(const Ping& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Ping& default_instance();

  void Swap(Ping* other);

  // implements Message ----------------------------------------------

  Ping* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Ping& from);
  void MergeFrom(const Ping& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:KismetExternal.Ping)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_kismet_2eproto();
  friend void protobuf_AssignDesc_kismet_2eproto();
  friend void protobuf_ShutdownFile_kismet_2eproto();

  void InitAsDefaultInstance();
  static Ping* default_instance_;
};
// -------------------------------------------------------------------

class Pong : public ::google::protobuf::Message {
 public:
  Pong();
  virtual ~Pong();

  Pong(const Pong& from);

  inline Pong& operator=(const Pong& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Pong& default_instance();

  void Swap(Pong* other);

  // implements Message ----------------------------------------------

  Pong* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Pong& from);
  void MergeFrom(const Pong& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 ping_seqno = 1;
  inline bool has_ping_seqno() const;
  inline void clear_ping_seqno();
  static const int kPingSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 ping_seqno() const;
  inline void set_ping_seqno(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:KismetExternal.Pong)
 private:
  inline void set_has_ping_seqno();
  inline void clear_has_ping_seqno();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 ping_seqno_;
  friend void  protobuf_AddDesc_kismet_2eproto();
  friend void protobuf_AssignDesc_kismet_2eproto();
  friend void protobuf_ShutdownFile_kismet_2eproto();

  void InitAsDefaultInstance();
  static Pong* default_instance_;
};
// -------------------------------------------------------------------

class Shutdown : public ::google::protobuf::Message {
 public:
  Shutdown();
  virtual ~Shutdown();

  Shutdown(const Shutdown& from);

  inline Shutdown& operator=(const Shutdown& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Shutdown& default_instance();

  void Swap(Shutdown* other);

  // implements Message ----------------------------------------------

  Shutdown* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Shutdown& from);
  void MergeFrom(const Shutdown& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string reason = 1;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 1;
  inline const ::std::string& reason() const;
  inline void set_reason(const ::std::string& value);
  inline void set_reason(const char* value);
  inline void set_reason(const char* value, size_t size);
  inline ::std::string* mutable_reason();
  inline ::std::string* release_reason();
  inline void set_allocated_reason(::std::string* reason);

  // @@protoc_insertion_point(class_scope:KismetExternal.Shutdown)
 private:
  inline void set_has_reason();
  inline void clear_has_reason();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* reason_;
  friend void  protobuf_AddDesc_kismet_2eproto();
  friend void protobuf_AssignDesc_kismet_2eproto();
  friend void protobuf_ShutdownFile_kismet_2eproto();

  void InitAsDefaultInstance();
  static Shutdown* default_instance_;
};
// -------------------------------------------------------------------

class SystemRegister : public ::google::protobuf::Message {
 public:
  SystemRegister();
  virtual ~SystemRegister();

  SystemRegister(const SystemRegister& from);

  inline SystemRegister& operator=(const SystemRegister& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SystemRegister& default_instance();

  void Swap(SystemRegister* other);

  // implements Message ----------------------------------------------

  SystemRegister* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SystemRegister& from);
  void MergeFrom(const SystemRegister& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string subsystem = 1;
  inline bool has_subsystem() const;
  inline void clear_subsystem();
  static const int kSubsystemFieldNumber = 1;
  inline const ::std::string& subsystem() const;
  inline void set_subsystem(const ::std::string& value);
  inline void set_subsystem(const char* value);
  inline void set_subsystem(const char* value, size_t size);
  inline ::std::string* mutable_subsystem();
  inline ::std::string* release_subsystem();
  inline void set_allocated_subsystem(::std::string* subsystem);

  // @@protoc_insertion_point(class_scope:KismetExternal.SystemRegister)
 private:
  inline void set_has_subsystem();
  inline void clear_has_subsystem();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* subsystem_;
  friend void  protobuf_AddDesc_kismet_2eproto();
  friend void protobuf_AssignDesc_kismet_2eproto();
  friend void protobuf_ShutdownFile_kismet_2eproto();

  void InitAsDefaultInstance();
  static SystemRegister* default_instance_;
};
// ===================================================================


// ===================================================================

// Command

// required string command = 1;
inline bool Command::has_command() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Command::set_has_command() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Command::clear_has_command() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Command::clear_command() {
  if (command_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    command_->clear();
  }
  clear_has_command();
}
inline const ::std::string& Command::command() const {
  // @@protoc_insertion_point(field_get:KismetExternal.Command.command)
  return *command_;
}
inline void Command::set_command(const ::std::string& value) {
  set_has_command();
  if (command_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    command_ = new ::std::string;
  }
  command_->assign(value);
  // @@protoc_insertion_point(field_set:KismetExternal.Command.command)
}
inline void Command::set_command(const char* value) {
  set_has_command();
  if (command_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    command_ = new ::std::string;
  }
  command_->assign(value);
  // @@protoc_insertion_point(field_set_char:KismetExternal.Command.command)
}
inline void Command::set_command(const char* value, size_t size) {
  set_has_command();
  if (command_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    command_ = new ::std::string;
  }
  command_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:KismetExternal.Command.command)
}
inline ::std::string* Command::mutable_command() {
  set_has_command();
  if (command_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    command_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:KismetExternal.Command.command)
  return command_;
}
inline ::std::string* Command::release_command() {
  clear_has_command();
  if (command_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = command_;
    command_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Command::set_allocated_command(::std::string* command) {
  if (command_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete command_;
  }
  if (command) {
    set_has_command();
    command_ = command;
  } else {
    clear_has_command();
    command_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:KismetExternal.Command.command)
}

// required uint32 seqno = 2;
inline bool Command::has_seqno() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Command::set_has_seqno() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Command::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Command::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 Command::seqno() const {
  // @@protoc_insertion_point(field_get:KismetExternal.Command.seqno)
  return seqno_;
}
inline void Command::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
  // @@protoc_insertion_point(field_set:KismetExternal.Command.seqno)
}

// required bytes content = 3;
inline bool Command::has_content() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Command::set_has_content() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Command::clear_has_content() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Command::clear_content() {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& Command::content() const {
  // @@protoc_insertion_point(field_get:KismetExternal.Command.content)
  return *content_;
}
inline void Command::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set:KismetExternal.Command.content)
}
inline void Command::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set_char:KismetExternal.Command.content)
}
inline void Command::set_content(const void* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:KismetExternal.Command.content)
}
inline ::std::string* Command::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:KismetExternal.Command.content)
  return content_;
}
inline ::std::string* Command::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Command::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:KismetExternal.Command.content)
}

// -------------------------------------------------------------------

// MsgbusMessage

// required .KismetExternal.MsgbusMessage.MessageType msgtype = 1;
inline bool MsgbusMessage::has_msgtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgbusMessage::set_has_msgtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgbusMessage::clear_has_msgtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgbusMessage::clear_msgtype() {
  msgtype_ = 1;
  clear_has_msgtype();
}
inline ::KismetExternal::MsgbusMessage_MessageType MsgbusMessage::msgtype() const {
  // @@protoc_insertion_point(field_get:KismetExternal.MsgbusMessage.msgtype)
  return static_cast< ::KismetExternal::MsgbusMessage_MessageType >(msgtype_);
}
inline void MsgbusMessage::set_msgtype(::KismetExternal::MsgbusMessage_MessageType value) {
  assert(::KismetExternal::MsgbusMessage_MessageType_IsValid(value));
  set_has_msgtype();
  msgtype_ = value;
  // @@protoc_insertion_point(field_set:KismetExternal.MsgbusMessage.msgtype)
}

// required string msgtext = 2;
inline bool MsgbusMessage::has_msgtext() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgbusMessage::set_has_msgtext() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgbusMessage::clear_has_msgtext() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgbusMessage::clear_msgtext() {
  if (msgtext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgtext_->clear();
  }
  clear_has_msgtext();
}
inline const ::std::string& MsgbusMessage::msgtext() const {
  // @@protoc_insertion_point(field_get:KismetExternal.MsgbusMessage.msgtext)
  return *msgtext_;
}
inline void MsgbusMessage::set_msgtext(const ::std::string& value) {
  set_has_msgtext();
  if (msgtext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgtext_ = new ::std::string;
  }
  msgtext_->assign(value);
  // @@protoc_insertion_point(field_set:KismetExternal.MsgbusMessage.msgtext)
}
inline void MsgbusMessage::set_msgtext(const char* value) {
  set_has_msgtext();
  if (msgtext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgtext_ = new ::std::string;
  }
  msgtext_->assign(value);
  // @@protoc_insertion_point(field_set_char:KismetExternal.MsgbusMessage.msgtext)
}
inline void MsgbusMessage::set_msgtext(const char* value, size_t size) {
  set_has_msgtext();
  if (msgtext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgtext_ = new ::std::string;
  }
  msgtext_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:KismetExternal.MsgbusMessage.msgtext)
}
inline ::std::string* MsgbusMessage::mutable_msgtext() {
  set_has_msgtext();
  if (msgtext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgtext_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:KismetExternal.MsgbusMessage.msgtext)
  return msgtext_;
}
inline ::std::string* MsgbusMessage::release_msgtext() {
  clear_has_msgtext();
  if (msgtext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = msgtext_;
    msgtext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MsgbusMessage::set_allocated_msgtext(::std::string* msgtext) {
  if (msgtext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete msgtext_;
  }
  if (msgtext) {
    set_has_msgtext();
    msgtext_ = msgtext;
  } else {
    clear_has_msgtext();
    msgtext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:KismetExternal.MsgbusMessage.msgtext)
}

// -------------------------------------------------------------------

// Ping

// -------------------------------------------------------------------

// Pong

// required uint32 ping_seqno = 1;
inline bool Pong::has_ping_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Pong::set_has_ping_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Pong::clear_has_ping_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Pong::clear_ping_seqno() {
  ping_seqno_ = 0u;
  clear_has_ping_seqno();
}
inline ::google::protobuf::uint32 Pong::ping_seqno() const {
  // @@protoc_insertion_point(field_get:KismetExternal.Pong.ping_seqno)
  return ping_seqno_;
}
inline void Pong::set_ping_seqno(::google::protobuf::uint32 value) {
  set_has_ping_seqno();
  ping_seqno_ = value;
  // @@protoc_insertion_point(field_set:KismetExternal.Pong.ping_seqno)
}

// -------------------------------------------------------------------

// Shutdown

// required string reason = 1;
inline bool Shutdown::has_reason() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Shutdown::set_has_reason() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Shutdown::clear_has_reason() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Shutdown::clear_reason() {
  if (reason_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reason_->clear();
  }
  clear_has_reason();
}
inline const ::std::string& Shutdown::reason() const {
  // @@protoc_insertion_point(field_get:KismetExternal.Shutdown.reason)
  return *reason_;
}
inline void Shutdown::set_reason(const ::std::string& value) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
  // @@protoc_insertion_point(field_set:KismetExternal.Shutdown.reason)
}
inline void Shutdown::set_reason(const char* value) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
  // @@protoc_insertion_point(field_set_char:KismetExternal.Shutdown.reason)
}
inline void Shutdown::set_reason(const char* value, size_t size) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reason_ = new ::std::string;
  }
  reason_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:KismetExternal.Shutdown.reason)
}
inline ::std::string* Shutdown::mutable_reason() {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reason_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:KismetExternal.Shutdown.reason)
  return reason_;
}
inline ::std::string* Shutdown::release_reason() {
  clear_has_reason();
  if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = reason_;
    reason_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Shutdown::set_allocated_reason(::std::string* reason) {
  if (reason_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete reason_;
  }
  if (reason) {
    set_has_reason();
    reason_ = reason;
  } else {
    clear_has_reason();
    reason_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:KismetExternal.Shutdown.reason)
}

// -------------------------------------------------------------------

// SystemRegister

// required string subsystem = 1;
inline bool SystemRegister::has_subsystem() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SystemRegister::set_has_subsystem() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SystemRegister::clear_has_subsystem() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SystemRegister::clear_subsystem() {
  if (subsystem_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subsystem_->clear();
  }
  clear_has_subsystem();
}
inline const ::std::string& SystemRegister::subsystem() const {
  // @@protoc_insertion_point(field_get:KismetExternal.SystemRegister.subsystem)
  return *subsystem_;
}
inline void SystemRegister::set_subsystem(const ::std::string& value) {
  set_has_subsystem();
  if (subsystem_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subsystem_ = new ::std::string;
  }
  subsystem_->assign(value);
  // @@protoc_insertion_point(field_set:KismetExternal.SystemRegister.subsystem)
}
inline void SystemRegister::set_subsystem(const char* value) {
  set_has_subsystem();
  if (subsystem_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subsystem_ = new ::std::string;
  }
  subsystem_->assign(value);
  // @@protoc_insertion_point(field_set_char:KismetExternal.SystemRegister.subsystem)
}
inline void SystemRegister::set_subsystem(const char* value, size_t size) {
  set_has_subsystem();
  if (subsystem_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subsystem_ = new ::std::string;
  }
  subsystem_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:KismetExternal.SystemRegister.subsystem)
}
inline ::std::string* SystemRegister::mutable_subsystem() {
  set_has_subsystem();
  if (subsystem_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subsystem_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:KismetExternal.SystemRegister.subsystem)
  return subsystem_;
}
inline ::std::string* SystemRegister::release_subsystem() {
  clear_has_subsystem();
  if (subsystem_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = subsystem_;
    subsystem_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SystemRegister::set_allocated_subsystem(::std::string* subsystem) {
  if (subsystem_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete subsystem_;
  }
  if (subsystem) {
    set_has_subsystem();
    subsystem_ = subsystem;
  } else {
    clear_has_subsystem();
    subsystem_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:KismetExternal.SystemRegister.subsystem)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace KismetExternal

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::KismetExternal::MsgbusMessage_MessageType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::KismetExternal::MsgbusMessage_MessageType>() {
  return ::KismetExternal::MsgbusMessage_MessageType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_kismet_2eproto__INCLUDED
