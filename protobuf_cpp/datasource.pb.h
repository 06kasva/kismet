// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: datasource.proto

#ifndef PROTOBUF_datasource_2eproto__INCLUDED
#define PROTOBUF_datasource_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace KismetDatasource {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_datasource_2eproto();
void protobuf_AssignDesc_datasource_2eproto();
void protobuf_ShutdownFile_datasource_2eproto();

class Channels;
class CloseDatasource;
class Configure;
class ConfigureReport;
class DataReport;
class ErrorReport;
class InterfacesReport;
class ListInterfaces;
class Message;
class NewSource;
class OpenSource;
class OpenSourceReport;
class ProbeSource;
class ProbeSourceReport;
class SubChanhop;
class SubChannels;
class SubChanset;
class SubGps;
class SubInterface;
class SubMsgbus;
class SubPacket;
class SubSignal;
class SubSpecset;
class SubSpectrum;
class SubSuccess;

enum SubMsgbus_MessageType {
  SubMsgbus_MessageType_DEBUG = 1,
  SubMsgbus_MessageType_INFO = 2,
  SubMsgbus_MessageType_ERROR = 4,
  SubMsgbus_MessageType_ALERT = 8,
  SubMsgbus_MessageType_FATAL = 16
};
bool SubMsgbus_MessageType_IsValid(int value);
const SubMsgbus_MessageType SubMsgbus_MessageType_MessageType_MIN = SubMsgbus_MessageType_DEBUG;
const SubMsgbus_MessageType SubMsgbus_MessageType_MessageType_MAX = SubMsgbus_MessageType_FATAL;
const int SubMsgbus_MessageType_MessageType_ARRAYSIZE = SubMsgbus_MessageType_MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SubMsgbus_MessageType_descriptor();
inline const ::std::string& SubMsgbus_MessageType_Name(SubMsgbus_MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SubMsgbus_MessageType_descriptor(), value);
}
inline bool SubMsgbus_MessageType_Parse(
    const ::std::string& name, SubMsgbus_MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SubMsgbus_MessageType>(
    SubMsgbus_MessageType_descriptor(), name, value);
}
// ===================================================================

class SubChannels : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:KismetDatasource.SubChannels) */ {
 public:
  SubChannels();
  virtual ~SubChannels();

  SubChannels(const SubChannels& from);

  inline SubChannels& operator=(const SubChannels& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SubChannels& default_instance();

  void Swap(SubChannels* other);

  // implements Message ----------------------------------------------

  inline SubChannels* New() const { return New(NULL); }

  SubChannels* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SubChannels& from);
  void MergeFrom(const SubChannels& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SubChannels* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string channels = 1;
  int channels_size() const;
  void clear_channels();
  static const int kChannelsFieldNumber = 1;
  const ::std::string& channels(int index) const;
  ::std::string* mutable_channels(int index);
  void set_channels(int index, const ::std::string& value);
  void set_channels(int index, const char* value);
  void set_channels(int index, const char* value, size_t size);
  ::std::string* add_channels();
  void add_channels(const ::std::string& value);
  void add_channels(const char* value);
  void add_channels(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& channels() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_channels();

  // @@protoc_insertion_point(class_scope:KismetDatasource.SubChannels)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> channels_;
  friend void  protobuf_AddDesc_datasource_2eproto();
  friend void protobuf_AssignDesc_datasource_2eproto();
  friend void protobuf_ShutdownFile_datasource_2eproto();

  void InitAsDefaultInstance();
  static SubChannels* default_instance_;
};
// -------------------------------------------------------------------

class SubChanset : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:KismetDatasource.SubChanset) */ {
 public:
  SubChanset();
  virtual ~SubChanset();

  SubChanset(const SubChanset& from);

  inline SubChanset& operator=(const SubChanset& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SubChanset& default_instance();

  void Swap(SubChanset* other);

  // implements Message ----------------------------------------------

  inline SubChanset* New() const { return New(NULL); }

  SubChanset* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SubChanset& from);
  void MergeFrom(const SubChanset& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SubChanset* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string channel = 1;
  bool has_channel() const;
  void clear_channel();
  static const int kChannelFieldNumber = 1;
  const ::std::string& channel() const;
  void set_channel(const ::std::string& value);
  void set_channel(const char* value);
  void set_channel(const char* value, size_t size);
  ::std::string* mutable_channel();
  ::std::string* release_channel();
  void set_allocated_channel(::std::string* channel);

  // @@protoc_insertion_point(class_scope:KismetDatasource.SubChanset)
 private:
  inline void set_has_channel();
  inline void clear_has_channel();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr channel_;
  friend void  protobuf_AddDesc_datasource_2eproto();
  friend void protobuf_AssignDesc_datasource_2eproto();
  friend void protobuf_ShutdownFile_datasource_2eproto();

  void InitAsDefaultInstance();
  static SubChanset* default_instance_;
};
// -------------------------------------------------------------------

class SubChanhop : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:KismetDatasource.SubChanhop) */ {
 public:
  SubChanhop();
  virtual ~SubChanhop();

  SubChanhop(const SubChanhop& from);

  inline SubChanhop& operator=(const SubChanhop& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SubChanhop& default_instance();

  void Swap(SubChanhop* other);

  // implements Message ----------------------------------------------

  inline SubChanhop* New() const { return New(NULL); }

  SubChanhop* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SubChanhop& from);
  void MergeFrom(const SubChanhop& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SubChanhop* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string channels = 1;
  int channels_size() const;
  void clear_channels();
  static const int kChannelsFieldNumber = 1;
  const ::std::string& channels(int index) const;
  ::std::string* mutable_channels(int index);
  void set_channels(int index, const ::std::string& value);
  void set_channels(int index, const char* value);
  void set_channels(int index, const char* value, size_t size);
  ::std::string* add_channels();
  void add_channels(const ::std::string& value);
  void add_channels(const char* value);
  void add_channels(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& channels() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_channels();

  // optional double rate = 2;
  bool has_rate() const;
  void clear_rate();
  static const int kRateFieldNumber = 2;
  double rate() const;
  void set_rate(double value);

  // optional bool shuffle = 3;
  bool has_shuffle() const;
  void clear_shuffle();
  static const int kShuffleFieldNumber = 3;
  bool shuffle() const;
  void set_shuffle(bool value);

  // optional uint32 shuffle_skip = 4;
  bool has_shuffle_skip() const;
  void clear_shuffle_skip();
  static const int kShuffleSkipFieldNumber = 4;
  ::google::protobuf::uint32 shuffle_skip() const;
  void set_shuffle_skip(::google::protobuf::uint32 value);

  // optional uint32 offset = 5;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 5;
  ::google::protobuf::uint32 offset() const;
  void set_offset(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:KismetDatasource.SubChanhop)
 private:
  inline void set_has_rate();
  inline void clear_has_rate();
  inline void set_has_shuffle();
  inline void clear_has_shuffle();
  inline void set_has_shuffle_skip();
  inline void clear_has_shuffle_skip();
  inline void set_has_offset();
  inline void clear_has_offset();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> channels_;
  double rate_;
  bool shuffle_;
  ::google::protobuf::uint32 shuffle_skip_;
  ::google::protobuf::uint32 offset_;
  friend void  protobuf_AddDesc_datasource_2eproto();
  friend void protobuf_AssignDesc_datasource_2eproto();
  friend void protobuf_ShutdownFile_datasource_2eproto();

  void InitAsDefaultInstance();
  static SubChanhop* default_instance_;
};
// -------------------------------------------------------------------

class SubGps : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:KismetDatasource.SubGps) */ {
 public:
  SubGps();
  virtual ~SubGps();

  SubGps(const SubGps& from);

  inline SubGps& operator=(const SubGps& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SubGps& default_instance();

  void Swap(SubGps* other);

  // implements Message ----------------------------------------------

  inline SubGps* New() const { return New(NULL); }

  SubGps* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SubGps& from);
  void MergeFrom(const SubGps& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SubGps* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double lat = 1;
  bool has_lat() const;
  void clear_lat();
  static const int kLatFieldNumber = 1;
  double lat() const;
  void set_lat(double value);

  // required double lon = 2;
  bool has_lon() const;
  void clear_lon();
  static const int kLonFieldNumber = 2;
  double lon() const;
  void set_lon(double value);

  // required double alt = 3;
  bool has_alt() const;
  void clear_alt();
  static const int kAltFieldNumber = 3;
  double alt() const;
  void set_alt(double value);

  // required double speed = 4;
  bool has_speed() const;
  void clear_speed();
  static const int kSpeedFieldNumber = 4;
  double speed() const;
  void set_speed(double value);

  // required double heading = 5;
  bool has_heading() const;
  void clear_heading();
  static const int kHeadingFieldNumber = 5;
  double heading() const;
  void set_heading(double value);

  // required double precision = 6;
  bool has_precision() const;
  void clear_precision();
  static const int kPrecisionFieldNumber = 6;
  double precision() const;
  void set_precision(double value);

  // required uint32 fix = 7;
  bool has_fix() const;
  void clear_fix();
  static const int kFixFieldNumber = 7;
  ::google::protobuf::uint32 fix() const;
  void set_fix(::google::protobuf::uint32 value);

  // required uint64 time_sec = 8;
  bool has_time_sec() const;
  void clear_time_sec();
  static const int kTimeSecFieldNumber = 8;
  ::google::protobuf::uint64 time_sec() const;
  void set_time_sec(::google::protobuf::uint64 value);

  // required uint64 time_usec = 9;
  bool has_time_usec() const;
  void clear_time_usec();
  static const int kTimeUsecFieldNumber = 9;
  ::google::protobuf::uint64 time_usec() const;
  void set_time_usec(::google::protobuf::uint64 value);

  // required string type = 10;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 10;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // required string name = 11;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 11;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:KismetDatasource.SubGps)
 private:
  inline void set_has_lat();
  inline void clear_has_lat();
  inline void set_has_lon();
  inline void clear_has_lon();
  inline void set_has_alt();
  inline void clear_has_alt();
  inline void set_has_speed();
  inline void clear_has_speed();
  inline void set_has_heading();
  inline void clear_has_heading();
  inline void set_has_precision();
  inline void clear_has_precision();
  inline void set_has_fix();
  inline void clear_has_fix();
  inline void set_has_time_sec();
  inline void clear_has_time_sec();
  inline void set_has_time_usec();
  inline void clear_has_time_usec();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_name();
  inline void clear_has_name();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double lat_;
  double lon_;
  double alt_;
  double speed_;
  double heading_;
  double precision_;
  ::google::protobuf::uint64 time_sec_;
  ::google::protobuf::uint64 time_usec_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint32 fix_;
  friend void  protobuf_AddDesc_datasource_2eproto();
  friend void protobuf_AssignDesc_datasource_2eproto();
  friend void protobuf_ShutdownFile_datasource_2eproto();

  void InitAsDefaultInstance();
  static SubGps* default_instance_;
};
// -------------------------------------------------------------------

class SubInterface : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:KismetDatasource.SubInterface) */ {
 public:
  SubInterface();
  virtual ~SubInterface();

  SubInterface(const SubInterface& from);

  inline SubInterface& operator=(const SubInterface& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SubInterface& default_instance();

  void Swap(SubInterface* other);

  // implements Message ----------------------------------------------

  inline SubInterface* New() const { return New(NULL); }

  SubInterface* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SubInterface& from);
  void MergeFrom(const SubInterface& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SubInterface* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string interface = 1;
  bool has_interface() const;
  void clear_interface();
  static const int kInterfaceFieldNumber = 1;
  const ::std::string& interface() const;
  void set_interface(const ::std::string& value);
  void set_interface(const char* value);
  void set_interface(const char* value, size_t size);
  ::std::string* mutable_interface();
  ::std::string* release_interface();
  void set_allocated_interface(::std::string* interface);

  // required string flags = 2;
  bool has_flags() const;
  void clear_flags();
  static const int kFlagsFieldNumber = 2;
  const ::std::string& flags() const;
  void set_flags(const ::std::string& value);
  void set_flags(const char* value);
  void set_flags(const char* value, size_t size);
  ::std::string* mutable_flags();
  ::std::string* release_flags();
  void set_allocated_flags(::std::string* flags);

  // optional string hardware = 3;
  bool has_hardware() const;
  void clear_hardware();
  static const int kHardwareFieldNumber = 3;
  const ::std::string& hardware() const;
  void set_hardware(const ::std::string& value);
  void set_hardware(const char* value);
  void set_hardware(const char* value, size_t size);
  ::std::string* mutable_hardware();
  ::std::string* release_hardware();
  void set_allocated_hardware(::std::string* hardware);

  // @@protoc_insertion_point(class_scope:KismetDatasource.SubInterface)
 private:
  inline void set_has_interface();
  inline void clear_has_interface();
  inline void set_has_flags();
  inline void clear_has_flags();
  inline void set_has_hardware();
  inline void clear_has_hardware();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr interface_;
  ::google::protobuf::internal::ArenaStringPtr flags_;
  ::google::protobuf::internal::ArenaStringPtr hardware_;
  friend void  protobuf_AddDesc_datasource_2eproto();
  friend void protobuf_AssignDesc_datasource_2eproto();
  friend void protobuf_ShutdownFile_datasource_2eproto();

  void InitAsDefaultInstance();
  static SubInterface* default_instance_;
};
// -------------------------------------------------------------------

class SubMsgbus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:KismetDatasource.SubMsgbus) */ {
 public:
  SubMsgbus();
  virtual ~SubMsgbus();

  SubMsgbus(const SubMsgbus& from);

  inline SubMsgbus& operator=(const SubMsgbus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SubMsgbus& default_instance();

  void Swap(SubMsgbus* other);

  // implements Message ----------------------------------------------

  inline SubMsgbus* New() const { return New(NULL); }

  SubMsgbus* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SubMsgbus& from);
  void MergeFrom(const SubMsgbus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SubMsgbus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SubMsgbus_MessageType MessageType;
  static const MessageType DEBUG =
    SubMsgbus_MessageType_DEBUG;
  static const MessageType INFO =
    SubMsgbus_MessageType_INFO;
  static const MessageType ERROR =
    SubMsgbus_MessageType_ERROR;
  static const MessageType ALERT =
    SubMsgbus_MessageType_ALERT;
  static const MessageType FATAL =
    SubMsgbus_MessageType_FATAL;
  static inline bool MessageType_IsValid(int value) {
    return SubMsgbus_MessageType_IsValid(value);
  }
  static const MessageType MessageType_MIN =
    SubMsgbus_MessageType_MessageType_MIN;
  static const MessageType MessageType_MAX =
    SubMsgbus_MessageType_MessageType_MAX;
  static const int MessageType_ARRAYSIZE =
    SubMsgbus_MessageType_MessageType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MessageType_descriptor() {
    return SubMsgbus_MessageType_descriptor();
  }
  static inline const ::std::string& MessageType_Name(MessageType value) {
    return SubMsgbus_MessageType_Name(value);
  }
  static inline bool MessageType_Parse(const ::std::string& name,
      MessageType* value) {
    return SubMsgbus_MessageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .KismetDatasource.SubMsgbus.MessageType msgtype = 1;
  bool has_msgtype() const;
  void clear_msgtype();
  static const int kMsgtypeFieldNumber = 1;
  ::KismetDatasource::SubMsgbus_MessageType msgtype() const;
  void set_msgtype(::KismetDatasource::SubMsgbus_MessageType value);

  // required string msgtext = 2;
  bool has_msgtext() const;
  void clear_msgtext();
  static const int kMsgtextFieldNumber = 2;
  const ::std::string& msgtext() const;
  void set_msgtext(const ::std::string& value);
  void set_msgtext(const char* value);
  void set_msgtext(const char* value, size_t size);
  ::std::string* mutable_msgtext();
  ::std::string* release_msgtext();
  void set_allocated_msgtext(::std::string* msgtext);

  // @@protoc_insertion_point(class_scope:KismetDatasource.SubMsgbus)
 private:
  inline void set_has_msgtype();
  inline void clear_has_msgtype();
  inline void set_has_msgtext();
  inline void clear_has_msgtext();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr msgtext_;
  int msgtype_;
  friend void  protobuf_AddDesc_datasource_2eproto();
  friend void protobuf_AssignDesc_datasource_2eproto();
  friend void protobuf_ShutdownFile_datasource_2eproto();

  void InitAsDefaultInstance();
  static SubMsgbus* default_instance_;
};
// -------------------------------------------------------------------

class SubPacket : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:KismetDatasource.SubPacket) */ {
 public:
  SubPacket();
  virtual ~SubPacket();

  SubPacket(const SubPacket& from);

  inline SubPacket& operator=(const SubPacket& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SubPacket& default_instance();

  void Swap(SubPacket* other);

  // implements Message ----------------------------------------------

  inline SubPacket* New() const { return New(NULL); }

  SubPacket* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SubPacket& from);
  void MergeFrom(const SubPacket& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SubPacket* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 time_sec = 1;
  bool has_time_sec() const;
  void clear_time_sec();
  static const int kTimeSecFieldNumber = 1;
  ::google::protobuf::uint64 time_sec() const;
  void set_time_sec(::google::protobuf::uint64 value);

  // required uint64 time_usec = 2;
  bool has_time_usec() const;
  void clear_time_usec();
  static const int kTimeUsecFieldNumber = 2;
  ::google::protobuf::uint64 time_usec() const;
  void set_time_usec(::google::protobuf::uint64 value);

  // required uint32 dlt = 3;
  bool has_dlt() const;
  void clear_dlt();
  static const int kDltFieldNumber = 3;
  ::google::protobuf::uint32 dlt() const;
  void set_dlt(::google::protobuf::uint32 value);

  // required uint64 size = 4;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 4;
  ::google::protobuf::uint64 size() const;
  void set_size(::google::protobuf::uint64 value);

  // required bytes data = 5;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 5;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:KismetDatasource.SubPacket)
 private:
  inline void set_has_time_sec();
  inline void clear_has_time_sec();
  inline void set_has_time_usec();
  inline void clear_has_time_usec();
  inline void set_has_dlt();
  inline void clear_has_dlt();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_data();
  inline void clear_has_data();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 time_sec_;
  ::google::protobuf::uint64 time_usec_;
  ::google::protobuf::uint64 size_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::uint32 dlt_;
  friend void  protobuf_AddDesc_datasource_2eproto();
  friend void protobuf_AssignDesc_datasource_2eproto();
  friend void protobuf_ShutdownFile_datasource_2eproto();

  void InitAsDefaultInstance();
  static SubPacket* default_instance_;
};
// -------------------------------------------------------------------

class SubSignal : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:KismetDatasource.SubSignal) */ {
 public:
  SubSignal();
  virtual ~SubSignal();

  SubSignal(const SubSignal& from);

  inline SubSignal& operator=(const SubSignal& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SubSignal& default_instance();

  void Swap(SubSignal* other);

  // implements Message ----------------------------------------------

  inline SubSignal* New() const { return New(NULL); }

  SubSignal* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SubSignal& from);
  void MergeFrom(const SubSignal& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SubSignal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double signal_dbm = 1;
  bool has_signal_dbm() const;
  void clear_signal_dbm();
  static const int kSignalDbmFieldNumber = 1;
  double signal_dbm() const;
  void set_signal_dbm(double value);

  // optional double noise_dbm = 2;
  bool has_noise_dbm() const;
  void clear_noise_dbm();
  static const int kNoiseDbmFieldNumber = 2;
  double noise_dbm() const;
  void set_noise_dbm(double value);

  // optional double signal_rssi = 3;
  bool has_signal_rssi() const;
  void clear_signal_rssi();
  static const int kSignalRssiFieldNumber = 3;
  double signal_rssi() const;
  void set_signal_rssi(double value);

  // optional double noise_rssi = 4;
  bool has_noise_rssi() const;
  void clear_noise_rssi();
  static const int kNoiseRssiFieldNumber = 4;
  double noise_rssi() const;
  void set_noise_rssi(double value);

  // optional double freq_khz = 5;
  bool has_freq_khz() const;
  void clear_freq_khz();
  static const int kFreqKhzFieldNumber = 5;
  double freq_khz() const;
  void set_freq_khz(double value);

  // optional string channel = 6;
  bool has_channel() const;
  void clear_channel();
  static const int kChannelFieldNumber = 6;
  const ::std::string& channel() const;
  void set_channel(const ::std::string& value);
  void set_channel(const char* value);
  void set_channel(const char* value, size_t size);
  ::std::string* mutable_channel();
  ::std::string* release_channel();
  void set_allocated_channel(::std::string* channel);

  // optional double datarate = 7;
  bool has_datarate() const;
  void clear_datarate();
  static const int kDatarateFieldNumber = 7;
  double datarate() const;
  void set_datarate(double value);

  // @@protoc_insertion_point(class_scope:KismetDatasource.SubSignal)
 private:
  inline void set_has_signal_dbm();
  inline void clear_has_signal_dbm();
  inline void set_has_noise_dbm();
  inline void clear_has_noise_dbm();
  inline void set_has_signal_rssi();
  inline void clear_has_signal_rssi();
  inline void set_has_noise_rssi();
  inline void clear_has_noise_rssi();
  inline void set_has_freq_khz();
  inline void clear_has_freq_khz();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_datarate();
  inline void clear_has_datarate();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double signal_dbm_;
  double noise_dbm_;
  double signal_rssi_;
  double noise_rssi_;
  double freq_khz_;
  ::google::protobuf::internal::ArenaStringPtr channel_;
  double datarate_;
  friend void  protobuf_AddDesc_datasource_2eproto();
  friend void protobuf_AssignDesc_datasource_2eproto();
  friend void protobuf_ShutdownFile_datasource_2eproto();

  void InitAsDefaultInstance();
  static SubSignal* default_instance_;
};
// -------------------------------------------------------------------

class SubSpecset : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:KismetDatasource.SubSpecset) */ {
 public:
  SubSpecset();
  virtual ~SubSpecset();

  SubSpecset(const SubSpecset& from);

  inline SubSpecset& operator=(const SubSpecset& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SubSpecset& default_instance();

  void Swap(SubSpecset* other);

  // implements Message ----------------------------------------------

  inline SubSpecset* New() const { return New(NULL); }

  SubSpecset* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SubSpecset& from);
  void MergeFrom(const SubSpecset& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SubSpecset* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double start_mhz = 1;
  bool has_start_mhz() const;
  void clear_start_mhz();
  static const int kStartMhzFieldNumber = 1;
  double start_mhz() const;
  void set_start_mhz(double value);

  // optional double end_mhz = 2;
  bool has_end_mhz() const;
  void clear_end_mhz();
  static const int kEndMhzFieldNumber = 2;
  double end_mhz() const;
  void set_end_mhz(double value);

  // optional double samples_per_bucket = 3;
  bool has_samples_per_bucket() const;
  void clear_samples_per_bucket();
  static const int kSamplesPerBucketFieldNumber = 3;
  double samples_per_bucket() const;
  void set_samples_per_bucket(double value);

  // optional double bucket_width_hz = 4;
  bool has_bucket_width_hz() const;
  void clear_bucket_width_hz();
  static const int kBucketWidthHzFieldNumber = 4;
  double bucket_width_hz() const;
  void set_bucket_width_hz(double value);

  // optional bool enable_amp = 5;
  bool has_enable_amp() const;
  void clear_enable_amp();
  static const int kEnableAmpFieldNumber = 5;
  bool enable_amp() const;
  void set_enable_amp(bool value);

  // optional uint64 if_amp = 6;
  bool has_if_amp() const;
  void clear_if_amp();
  static const int kIfAmpFieldNumber = 6;
  ::google::protobuf::uint64 if_amp() const;
  void set_if_amp(::google::protobuf::uint64 value);

  // optional uint64 baseband_amp = 7;
  bool has_baseband_amp() const;
  void clear_baseband_amp();
  static const int kBasebandAmpFieldNumber = 7;
  ::google::protobuf::uint64 baseband_amp() const;
  void set_baseband_amp(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:KismetDatasource.SubSpecset)
 private:
  inline void set_has_start_mhz();
  inline void clear_has_start_mhz();
  inline void set_has_end_mhz();
  inline void clear_has_end_mhz();
  inline void set_has_samples_per_bucket();
  inline void clear_has_samples_per_bucket();
  inline void set_has_bucket_width_hz();
  inline void clear_has_bucket_width_hz();
  inline void set_has_enable_amp();
  inline void clear_has_enable_amp();
  inline void set_has_if_amp();
  inline void clear_has_if_amp();
  inline void set_has_baseband_amp();
  inline void clear_has_baseband_amp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double start_mhz_;
  double end_mhz_;
  double samples_per_bucket_;
  double bucket_width_hz_;
  ::google::protobuf::uint64 if_amp_;
  ::google::protobuf::uint64 baseband_amp_;
  bool enable_amp_;
  friend void  protobuf_AddDesc_datasource_2eproto();
  friend void protobuf_AssignDesc_datasource_2eproto();
  friend void protobuf_ShutdownFile_datasource_2eproto();

  void InitAsDefaultInstance();
  static SubSpecset* default_instance_;
};
// -------------------------------------------------------------------

class SubSpectrum : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:KismetDatasource.SubSpectrum) */ {
 public:
  SubSpectrum();
  virtual ~SubSpectrum();

  SubSpectrum(const SubSpectrum& from);

  inline SubSpectrum& operator=(const SubSpectrum& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SubSpectrum& default_instance();

  void Swap(SubSpectrum* other);

  // implements Message ----------------------------------------------

  inline SubSpectrum* New() const { return New(NULL); }

  SubSpectrum* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SubSpectrum& from);
  void MergeFrom(const SubSpectrum& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SubSpectrum* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 time_sec = 1;
  bool has_time_sec() const;
  void clear_time_sec();
  static const int kTimeSecFieldNumber = 1;
  ::google::protobuf::uint64 time_sec() const;
  void set_time_sec(::google::protobuf::uint64 value);

  // optional uint64 time_usec = 2;
  bool has_time_usec() const;
  void clear_time_usec();
  static const int kTimeUsecFieldNumber = 2;
  ::google::protobuf::uint64 time_usec() const;
  void set_time_usec(::google::protobuf::uint64 value);

  // optional double start_mhz = 3;
  bool has_start_mhz() const;
  void clear_start_mhz();
  static const int kStartMhzFieldNumber = 3;
  double start_mhz() const;
  void set_start_mhz(double value);

  // optional double end_mhz = 4;
  bool has_end_mhz() const;
  void clear_end_mhz();
  static const int kEndMhzFieldNumber = 4;
  double end_mhz() const;
  void set_end_mhz(double value);

  // optional double bucket_width_hz = 5;
  bool has_bucket_width_hz() const;
  void clear_bucket_width_hz();
  static const int kBucketWidthHzFieldNumber = 5;
  double bucket_width_hz() const;
  void set_bucket_width_hz(double value);

  // repeated int32 data = 6;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 6;
  ::google::protobuf::int32 data(int index) const;
  void set_data(int index, ::google::protobuf::int32 value);
  void add_data(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      data() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:KismetDatasource.SubSpectrum)
 private:
  inline void set_has_time_sec();
  inline void clear_has_time_sec();
  inline void set_has_time_usec();
  inline void clear_has_time_usec();
  inline void set_has_start_mhz();
  inline void clear_has_start_mhz();
  inline void set_has_end_mhz();
  inline void clear_has_end_mhz();
  inline void set_has_bucket_width_hz();
  inline void clear_has_bucket_width_hz();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 time_sec_;
  ::google::protobuf::uint64 time_usec_;
  double start_mhz_;
  double end_mhz_;
  double bucket_width_hz_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > data_;
  friend void  protobuf_AddDesc_datasource_2eproto();
  friend void protobuf_AssignDesc_datasource_2eproto();
  friend void protobuf_ShutdownFile_datasource_2eproto();

  void InitAsDefaultInstance();
  static SubSpectrum* default_instance_;
};
// -------------------------------------------------------------------

class SubSuccess : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:KismetDatasource.SubSuccess) */ {
 public:
  SubSuccess();
  virtual ~SubSuccess();

  SubSuccess(const SubSuccess& from);

  inline SubSuccess& operator=(const SubSuccess& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SubSuccess& default_instance();

  void Swap(SubSuccess* other);

  // implements Message ----------------------------------------------

  inline SubSuccess* New() const { return New(NULL); }

  SubSuccess* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SubSuccess& from);
  void MergeFrom(const SubSuccess& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SubSuccess* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool success = 1;
  bool has_success() const;
  void clear_success();
  static const int kSuccessFieldNumber = 1;
  bool success() const;
  void set_success(bool value);

  // required uint32 command_num = 2;
  bool has_command_num() const;
  void clear_command_num();
  static const int kCommandNumFieldNumber = 2;
  ::google::protobuf::uint32 command_num() const;
  void set_command_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:KismetDatasource.SubSuccess)
 private:
  inline void set_has_success();
  inline void clear_has_success();
  inline void set_has_command_num();
  inline void clear_has_command_num();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool success_;
  ::google::protobuf::uint32 command_num_;
  friend void  protobuf_AddDesc_datasource_2eproto();
  friend void protobuf_AssignDesc_datasource_2eproto();
  friend void protobuf_ShutdownFile_datasource_2eproto();

  void InitAsDefaultInstance();
  static SubSuccess* default_instance_;
};
// -------------------------------------------------------------------

class Channels : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:KismetDatasource.Channels) */ {
 public:
  Channels();
  virtual ~Channels();

  Channels(const Channels& from);

  inline Channels& operator=(const Channels& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Channels& default_instance();

  void Swap(Channels* other);

  // implements Message ----------------------------------------------

  inline Channels* New() const { return New(NULL); }

  Channels* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Channels& from);
  void MergeFrom(const Channels& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Channels* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .KismetDatasource.SubChannels channels = 1;
  bool has_channels() const;
  void clear_channels();
  static const int kChannelsFieldNumber = 1;
  const ::KismetDatasource::SubChannels& channels() const;
  ::KismetDatasource::SubChannels* mutable_channels();
  ::KismetDatasource::SubChannels* release_channels();
  void set_allocated_channels(::KismetDatasource::SubChannels* channels);

  // @@protoc_insertion_point(class_scope:KismetDatasource.Channels)
 private:
  inline void set_has_channels();
  inline void clear_has_channels();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::KismetDatasource::SubChannels* channels_;
  friend void  protobuf_AddDesc_datasource_2eproto();
  friend void protobuf_AssignDesc_datasource_2eproto();
  friend void protobuf_ShutdownFile_datasource_2eproto();

  void InitAsDefaultInstance();
  static Channels* default_instance_;
};
// -------------------------------------------------------------------

class CloseDatasource : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:KismetDatasource.CloseDatasource) */ {
 public:
  CloseDatasource();
  virtual ~CloseDatasource();

  CloseDatasource(const CloseDatasource& from);

  inline CloseDatasource& operator=(const CloseDatasource& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CloseDatasource& default_instance();

  void Swap(CloseDatasource* other);

  // implements Message ----------------------------------------------

  inline CloseDatasource* New() const { return New(NULL); }

  CloseDatasource* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CloseDatasource& from);
  void MergeFrom(const CloseDatasource& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CloseDatasource* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:KismetDatasource.CloseDatasource)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_datasource_2eproto();
  friend void protobuf_AssignDesc_datasource_2eproto();
  friend void protobuf_ShutdownFile_datasource_2eproto();

  void InitAsDefaultInstance();
  static CloseDatasource* default_instance_;
};
// -------------------------------------------------------------------

class Configure : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:KismetDatasource.Configure) */ {
 public:
  Configure();
  virtual ~Configure();

  Configure(const Configure& from);

  inline Configure& operator=(const Configure& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Configure& default_instance();

  void Swap(Configure* other);

  // implements Message ----------------------------------------------

  inline Configure* New() const { return New(NULL); }

  Configure* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Configure& from);
  void MergeFrom(const Configure& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Configure* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .KismetDatasource.SubChanset channel = 1;
  bool has_channel() const;
  void clear_channel();
  static const int kChannelFieldNumber = 1;
  const ::KismetDatasource::SubChanset& channel() const;
  ::KismetDatasource::SubChanset* mutable_channel();
  ::KismetDatasource::SubChanset* release_channel();
  void set_allocated_channel(::KismetDatasource::SubChanset* channel);

  // optional .KismetDatasource.SubChanhop hopping = 2;
  bool has_hopping() const;
  void clear_hopping();
  static const int kHoppingFieldNumber = 2;
  const ::KismetDatasource::SubChanhop& hopping() const;
  ::KismetDatasource::SubChanhop* mutable_hopping();
  ::KismetDatasource::SubChanhop* release_hopping();
  void set_allocated_hopping(::KismetDatasource::SubChanhop* hopping);

  // optional .KismetDatasource.SubSpecset spectrum = 3;
  bool has_spectrum() const;
  void clear_spectrum();
  static const int kSpectrumFieldNumber = 3;
  const ::KismetDatasource::SubSpecset& spectrum() const;
  ::KismetDatasource::SubSpecset* mutable_spectrum();
  ::KismetDatasource::SubSpecset* release_spectrum();
  void set_allocated_spectrum(::KismetDatasource::SubSpecset* spectrum);

  // @@protoc_insertion_point(class_scope:KismetDatasource.Configure)
 private:
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_hopping();
  inline void clear_has_hopping();
  inline void set_has_spectrum();
  inline void clear_has_spectrum();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::KismetDatasource::SubChanset* channel_;
  ::KismetDatasource::SubChanhop* hopping_;
  ::KismetDatasource::SubSpecset* spectrum_;
  friend void  protobuf_AddDesc_datasource_2eproto();
  friend void protobuf_AssignDesc_datasource_2eproto();
  friend void protobuf_ShutdownFile_datasource_2eproto();

  void InitAsDefaultInstance();
  static Configure* default_instance_;
};
// -------------------------------------------------------------------

class ConfigureReport : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:KismetDatasource.ConfigureReport) */ {
 public:
  ConfigureReport();
  virtual ~ConfigureReport();

  ConfigureReport(const ConfigureReport& from);

  inline ConfigureReport& operator=(const ConfigureReport& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConfigureReport& default_instance();

  void Swap(ConfigureReport* other);

  // implements Message ----------------------------------------------

  inline ConfigureReport* New() const { return New(NULL); }

  ConfigureReport* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConfigureReport& from);
  void MergeFrom(const ConfigureReport& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ConfigureReport* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .KismetDatasource.SubSuccess success = 1;
  bool has_success() const;
  void clear_success();
  static const int kSuccessFieldNumber = 1;
  const ::KismetDatasource::SubSuccess& success() const;
  ::KismetDatasource::SubSuccess* mutable_success();
  ::KismetDatasource::SubSuccess* release_success();
  void set_allocated_success(::KismetDatasource::SubSuccess* success);

  // optional .KismetDatasource.SubChanset channel = 2;
  bool has_channel() const;
  void clear_channel();
  static const int kChannelFieldNumber = 2;
  const ::KismetDatasource::SubChanset& channel() const;
  ::KismetDatasource::SubChanset* mutable_channel();
  ::KismetDatasource::SubChanset* release_channel();
  void set_allocated_channel(::KismetDatasource::SubChanset* channel);

  // optional .KismetDatasource.SubChanhop hopping = 3;
  bool has_hopping() const;
  void clear_hopping();
  static const int kHoppingFieldNumber = 3;
  const ::KismetDatasource::SubChanhop& hopping() const;
  ::KismetDatasource::SubChanhop* mutable_hopping();
  ::KismetDatasource::SubChanhop* release_hopping();
  void set_allocated_hopping(::KismetDatasource::SubChanhop* hopping);

  // optional .KismetDatasource.SubMsgbus message = 4;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 4;
  const ::KismetDatasource::SubMsgbus& message() const;
  ::KismetDatasource::SubMsgbus* mutable_message();
  ::KismetDatasource::SubMsgbus* release_message();
  void set_allocated_message(::KismetDatasource::SubMsgbus* message);

  // optional string warning = 5;
  bool has_warning() const;
  void clear_warning();
  static const int kWarningFieldNumber = 5;
  const ::std::string& warning() const;
  void set_warning(const ::std::string& value);
  void set_warning(const char* value);
  void set_warning(const char* value, size_t size);
  ::std::string* mutable_warning();
  ::std::string* release_warning();
  void set_allocated_warning(::std::string* warning);

  // @@protoc_insertion_point(class_scope:KismetDatasource.ConfigureReport)
 private:
  inline void set_has_success();
  inline void clear_has_success();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_hopping();
  inline void clear_has_hopping();
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_warning();
  inline void clear_has_warning();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::KismetDatasource::SubSuccess* success_;
  ::KismetDatasource::SubChanset* channel_;
  ::KismetDatasource::SubChanhop* hopping_;
  ::KismetDatasource::SubMsgbus* message_;
  ::google::protobuf::internal::ArenaStringPtr warning_;
  friend void  protobuf_AddDesc_datasource_2eproto();
  friend void protobuf_AssignDesc_datasource_2eproto();
  friend void protobuf_ShutdownFile_datasource_2eproto();

  void InitAsDefaultInstance();
  static ConfigureReport* default_instance_;
};
// -------------------------------------------------------------------

class DataReport : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:KismetDatasource.DataReport) */ {
 public:
  DataReport();
  virtual ~DataReport();

  DataReport(const DataReport& from);

  inline DataReport& operator=(const DataReport& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DataReport& default_instance();

  void Swap(DataReport* other);

  // implements Message ----------------------------------------------

  inline DataReport* New() const { return New(NULL); }

  DataReport* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DataReport& from);
  void MergeFrom(const DataReport& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DataReport* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .KismetDatasource.SubGps gps = 1;
  bool has_gps() const;
  void clear_gps();
  static const int kGpsFieldNumber = 1;
  const ::KismetDatasource::SubGps& gps() const;
  ::KismetDatasource::SubGps* mutable_gps();
  ::KismetDatasource::SubGps* release_gps();
  void set_allocated_gps(::KismetDatasource::SubGps* gps);

  // optional .KismetDatasource.SubMsgbus message = 2;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::KismetDatasource::SubMsgbus& message() const;
  ::KismetDatasource::SubMsgbus* mutable_message();
  ::KismetDatasource::SubMsgbus* release_message();
  void set_allocated_message(::KismetDatasource::SubMsgbus* message);

  // optional .KismetDatasource.SubPacket packet = 3;
  bool has_packet() const;
  void clear_packet();
  static const int kPacketFieldNumber = 3;
  const ::KismetDatasource::SubPacket& packet() const;
  ::KismetDatasource::SubPacket* mutable_packet();
  ::KismetDatasource::SubPacket* release_packet();
  void set_allocated_packet(::KismetDatasource::SubPacket* packet);

  // optional .KismetDatasource.SubSignal signal = 4;
  bool has_signal() const;
  void clear_signal();
  static const int kSignalFieldNumber = 4;
  const ::KismetDatasource::SubSignal& signal() const;
  ::KismetDatasource::SubSignal* mutable_signal();
  ::KismetDatasource::SubSignal* release_signal();
  void set_allocated_signal(::KismetDatasource::SubSignal* signal);

  // optional .KismetDatasource.SubSpectrum spectrum = 5;
  bool has_spectrum() const;
  void clear_spectrum();
  static const int kSpectrumFieldNumber = 5;
  const ::KismetDatasource::SubSpectrum& spectrum() const;
  ::KismetDatasource::SubSpectrum* mutable_spectrum();
  ::KismetDatasource::SubSpectrum* release_spectrum();
  void set_allocated_spectrum(::KismetDatasource::SubSpectrum* spectrum);

  // optional string warning = 6;
  bool has_warning() const;
  void clear_warning();
  static const int kWarningFieldNumber = 6;
  const ::std::string& warning() const;
  void set_warning(const ::std::string& value);
  void set_warning(const char* value);
  void set_warning(const char* value, size_t size);
  ::std::string* mutable_warning();
  ::std::string* release_warning();
  void set_allocated_warning(::std::string* warning);

  // @@protoc_insertion_point(class_scope:KismetDatasource.DataReport)
 private:
  inline void set_has_gps();
  inline void clear_has_gps();
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_packet();
  inline void clear_has_packet();
  inline void set_has_signal();
  inline void clear_has_signal();
  inline void set_has_spectrum();
  inline void clear_has_spectrum();
  inline void set_has_warning();
  inline void clear_has_warning();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::KismetDatasource::SubGps* gps_;
  ::KismetDatasource::SubMsgbus* message_;
  ::KismetDatasource::SubPacket* packet_;
  ::KismetDatasource::SubSignal* signal_;
  ::KismetDatasource::SubSpectrum* spectrum_;
  ::google::protobuf::internal::ArenaStringPtr warning_;
  friend void  protobuf_AddDesc_datasource_2eproto();
  friend void protobuf_AssignDesc_datasource_2eproto();
  friend void protobuf_ShutdownFile_datasource_2eproto();

  void InitAsDefaultInstance();
  static DataReport* default_instance_;
};
// -------------------------------------------------------------------

class ErrorReport : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:KismetDatasource.ErrorReport) */ {
 public:
  ErrorReport();
  virtual ~ErrorReport();

  ErrorReport(const ErrorReport& from);

  inline ErrorReport& operator=(const ErrorReport& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ErrorReport& default_instance();

  void Swap(ErrorReport* other);

  // implements Message ----------------------------------------------

  inline ErrorReport* New() const { return New(NULL); }

  ErrorReport* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ErrorReport& from);
  void MergeFrom(const ErrorReport& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ErrorReport* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .KismetDatasource.SubSuccess success = 1;
  bool has_success() const;
  void clear_success();
  static const int kSuccessFieldNumber = 1;
  const ::KismetDatasource::SubSuccess& success() const;
  ::KismetDatasource::SubSuccess* mutable_success();
  ::KismetDatasource::SubSuccess* release_success();
  void set_allocated_success(::KismetDatasource::SubSuccess* success);

  // optional .KismetDatasource.SubMsgbus message = 2;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::KismetDatasource::SubMsgbus& message() const;
  ::KismetDatasource::SubMsgbus* mutable_message();
  ::KismetDatasource::SubMsgbus* release_message();
  void set_allocated_message(::KismetDatasource::SubMsgbus* message);

  // @@protoc_insertion_point(class_scope:KismetDatasource.ErrorReport)
 private:
  inline void set_has_success();
  inline void clear_has_success();
  inline void set_has_message();
  inline void clear_has_message();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::KismetDatasource::SubSuccess* success_;
  ::KismetDatasource::SubMsgbus* message_;
  friend void  protobuf_AddDesc_datasource_2eproto();
  friend void protobuf_AssignDesc_datasource_2eproto();
  friend void protobuf_ShutdownFile_datasource_2eproto();

  void InitAsDefaultInstance();
  static ErrorReport* default_instance_;
};
// -------------------------------------------------------------------

class ListInterfaces : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:KismetDatasource.ListInterfaces) */ {
 public:
  ListInterfaces();
  virtual ~ListInterfaces();

  ListInterfaces(const ListInterfaces& from);

  inline ListInterfaces& operator=(const ListInterfaces& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListInterfaces& default_instance();

  void Swap(ListInterfaces* other);

  // implements Message ----------------------------------------------

  inline ListInterfaces* New() const { return New(NULL); }

  ListInterfaces* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListInterfaces& from);
  void MergeFrom(const ListInterfaces& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ListInterfaces* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:KismetDatasource.ListInterfaces)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_datasource_2eproto();
  friend void protobuf_AssignDesc_datasource_2eproto();
  friend void protobuf_ShutdownFile_datasource_2eproto();

  void InitAsDefaultInstance();
  static ListInterfaces* default_instance_;
};
// -------------------------------------------------------------------

class InterfacesReport : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:KismetDatasource.InterfacesReport) */ {
 public:
  InterfacesReport();
  virtual ~InterfacesReport();

  InterfacesReport(const InterfacesReport& from);

  inline InterfacesReport& operator=(const InterfacesReport& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InterfacesReport& default_instance();

  void Swap(InterfacesReport* other);

  // implements Message ----------------------------------------------

  inline InterfacesReport* New() const { return New(NULL); }

  InterfacesReport* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InterfacesReport& from);
  void MergeFrom(const InterfacesReport& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InterfacesReport* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .KismetDatasource.SubSuccess success = 1;
  bool has_success() const;
  void clear_success();
  static const int kSuccessFieldNumber = 1;
  const ::KismetDatasource::SubSuccess& success() const;
  ::KismetDatasource::SubSuccess* mutable_success();
  ::KismetDatasource::SubSuccess* release_success();
  void set_allocated_success(::KismetDatasource::SubSuccess* success);

  // optional .KismetDatasource.SubMsgbus message = 2;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::KismetDatasource::SubMsgbus& message() const;
  ::KismetDatasource::SubMsgbus* mutable_message();
  ::KismetDatasource::SubMsgbus* release_message();
  void set_allocated_message(::KismetDatasource::SubMsgbus* message);

  // repeated .KismetDatasource.SubInterface interfaces = 3;
  int interfaces_size() const;
  void clear_interfaces();
  static const int kInterfacesFieldNumber = 3;
  const ::KismetDatasource::SubInterface& interfaces(int index) const;
  ::KismetDatasource::SubInterface* mutable_interfaces(int index);
  ::KismetDatasource::SubInterface* add_interfaces();
  ::google::protobuf::RepeatedPtrField< ::KismetDatasource::SubInterface >*
      mutable_interfaces();
  const ::google::protobuf::RepeatedPtrField< ::KismetDatasource::SubInterface >&
      interfaces() const;

  // @@protoc_insertion_point(class_scope:KismetDatasource.InterfacesReport)
 private:
  inline void set_has_success();
  inline void clear_has_success();
  inline void set_has_message();
  inline void clear_has_message();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::KismetDatasource::SubSuccess* success_;
  ::KismetDatasource::SubMsgbus* message_;
  ::google::protobuf::RepeatedPtrField< ::KismetDatasource::SubInterface > interfaces_;
  friend void  protobuf_AddDesc_datasource_2eproto();
  friend void protobuf_AssignDesc_datasource_2eproto();
  friend void protobuf_ShutdownFile_datasource_2eproto();

  void InitAsDefaultInstance();
  static InterfacesReport* default_instance_;
};
// -------------------------------------------------------------------

class Message : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:KismetDatasource.Message) */ {
 public:
  Message();
  virtual ~Message();

  Message(const Message& from);

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();

  void Swap(Message* other);

  // implements Message ----------------------------------------------

  inline Message* New() const { return New(NULL); }

  Message* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Message* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .KismetDatasource.SubMsgbus message = 1;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 1;
  const ::KismetDatasource::SubMsgbus& message() const;
  ::KismetDatasource::SubMsgbus* mutable_message();
  ::KismetDatasource::SubMsgbus* release_message();
  void set_allocated_message(::KismetDatasource::SubMsgbus* message);

  // optional string warning = 2;
  bool has_warning() const;
  void clear_warning();
  static const int kWarningFieldNumber = 2;
  const ::std::string& warning() const;
  void set_warning(const ::std::string& value);
  void set_warning(const char* value);
  void set_warning(const char* value, size_t size);
  ::std::string* mutable_warning();
  ::std::string* release_warning();
  void set_allocated_warning(::std::string* warning);

  // @@protoc_insertion_point(class_scope:KismetDatasource.Message)
 private:
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_warning();
  inline void clear_has_warning();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::KismetDatasource::SubMsgbus* message_;
  ::google::protobuf::internal::ArenaStringPtr warning_;
  friend void  protobuf_AddDesc_datasource_2eproto();
  friend void protobuf_AssignDesc_datasource_2eproto();
  friend void protobuf_ShutdownFile_datasource_2eproto();

  void InitAsDefaultInstance();
  static Message* default_instance_;
};
// -------------------------------------------------------------------

class NewSource : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:KismetDatasource.NewSource) */ {
 public:
  NewSource();
  virtual ~NewSource();

  NewSource(const NewSource& from);

  inline NewSource& operator=(const NewSource& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NewSource& default_instance();

  void Swap(NewSource* other);

  // implements Message ----------------------------------------------

  inline NewSource* New() const { return New(NULL); }

  NewSource* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NewSource& from);
  void MergeFrom(const NewSource& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NewSource* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string definition = 1;
  bool has_definition() const;
  void clear_definition();
  static const int kDefinitionFieldNumber = 1;
  const ::std::string& definition() const;
  void set_definition(const ::std::string& value);
  void set_definition(const char* value);
  void set_definition(const char* value, size_t size);
  ::std::string* mutable_definition();
  ::std::string* release_definition();
  void set_allocated_definition(::std::string* definition);

  // required string sourcetype = 2;
  bool has_sourcetype() const;
  void clear_sourcetype();
  static const int kSourcetypeFieldNumber = 2;
  const ::std::string& sourcetype() const;
  void set_sourcetype(const ::std::string& value);
  void set_sourcetype(const char* value);
  void set_sourcetype(const char* value, size_t size);
  ::std::string* mutable_sourcetype();
  ::std::string* release_sourcetype();
  void set_allocated_sourcetype(::std::string* sourcetype);

  // required string uuid = 3;
  bool has_uuid() const;
  void clear_uuid();
  static const int kUuidFieldNumber = 3;
  const ::std::string& uuid() const;
  void set_uuid(const ::std::string& value);
  void set_uuid(const char* value);
  void set_uuid(const char* value, size_t size);
  ::std::string* mutable_uuid();
  ::std::string* release_uuid();
  void set_allocated_uuid(::std::string* uuid);

  // @@protoc_insertion_point(class_scope:KismetDatasource.NewSource)
 private:
  inline void set_has_definition();
  inline void clear_has_definition();
  inline void set_has_sourcetype();
  inline void clear_has_sourcetype();
  inline void set_has_uuid();
  inline void clear_has_uuid();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr definition_;
  ::google::protobuf::internal::ArenaStringPtr sourcetype_;
  ::google::protobuf::internal::ArenaStringPtr uuid_;
  friend void  protobuf_AddDesc_datasource_2eproto();
  friend void protobuf_AssignDesc_datasource_2eproto();
  friend void protobuf_ShutdownFile_datasource_2eproto();

  void InitAsDefaultInstance();
  static NewSource* default_instance_;
};
// -------------------------------------------------------------------

class OpenSource : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:KismetDatasource.OpenSource) */ {
 public:
  OpenSource();
  virtual ~OpenSource();

  OpenSource(const OpenSource& from);

  inline OpenSource& operator=(const OpenSource& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OpenSource& default_instance();

  void Swap(OpenSource* other);

  // implements Message ----------------------------------------------

  inline OpenSource* New() const { return New(NULL); }

  OpenSource* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OpenSource& from);
  void MergeFrom(const OpenSource& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OpenSource* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string definition = 1;
  bool has_definition() const;
  void clear_definition();
  static const int kDefinitionFieldNumber = 1;
  const ::std::string& definition() const;
  void set_definition(const ::std::string& value);
  void set_definition(const char* value);
  void set_definition(const char* value, size_t size);
  ::std::string* mutable_definition();
  ::std::string* release_definition();
  void set_allocated_definition(::std::string* definition);

  // @@protoc_insertion_point(class_scope:KismetDatasource.OpenSource)
 private:
  inline void set_has_definition();
  inline void clear_has_definition();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr definition_;
  friend void  protobuf_AddDesc_datasource_2eproto();
  friend void protobuf_AssignDesc_datasource_2eproto();
  friend void protobuf_ShutdownFile_datasource_2eproto();

  void InitAsDefaultInstance();
  static OpenSource* default_instance_;
};
// -------------------------------------------------------------------

class OpenSourceReport : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:KismetDatasource.OpenSourceReport) */ {
 public:
  OpenSourceReport();
  virtual ~OpenSourceReport();

  OpenSourceReport(const OpenSourceReport& from);

  inline OpenSourceReport& operator=(const OpenSourceReport& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OpenSourceReport& default_instance();

  void Swap(OpenSourceReport* other);

  // implements Message ----------------------------------------------

  inline OpenSourceReport* New() const { return New(NULL); }

  OpenSourceReport* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OpenSourceReport& from);
  void MergeFrom(const OpenSourceReport& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OpenSourceReport* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .KismetDatasource.SubSuccess success = 1;
  bool has_success() const;
  void clear_success();
  static const int kSuccessFieldNumber = 1;
  const ::KismetDatasource::SubSuccess& success() const;
  ::KismetDatasource::SubSuccess* mutable_success();
  ::KismetDatasource::SubSuccess* release_success();
  void set_allocated_success(::KismetDatasource::SubSuccess* success);

  // optional uint32 dlt = 2;
  bool has_dlt() const;
  void clear_dlt();
  static const int kDltFieldNumber = 2;
  ::google::protobuf::uint32 dlt() const;
  void set_dlt(::google::protobuf::uint32 value);

  // optional string capture_interface = 3;
  bool has_capture_interface() const;
  void clear_capture_interface();
  static const int kCaptureInterfaceFieldNumber = 3;
  const ::std::string& capture_interface() const;
  void set_capture_interface(const ::std::string& value);
  void set_capture_interface(const char* value);
  void set_capture_interface(const char* value, size_t size);
  ::std::string* mutable_capture_interface();
  ::std::string* release_capture_interface();
  void set_allocated_capture_interface(::std::string* capture_interface);

  // optional .KismetDatasource.SubChannels channels = 4;
  bool has_channels() const;
  void clear_channels();
  static const int kChannelsFieldNumber = 4;
  const ::KismetDatasource::SubChannels& channels() const;
  ::KismetDatasource::SubChannels* mutable_channels();
  ::KismetDatasource::SubChannels* release_channels();
  void set_allocated_channels(::KismetDatasource::SubChannels* channels);

  // optional .KismetDatasource.SubChanset channel = 5;
  bool has_channel() const;
  void clear_channel();
  static const int kChannelFieldNumber = 5;
  const ::KismetDatasource::SubChanset& channel() const;
  ::KismetDatasource::SubChanset* mutable_channel();
  ::KismetDatasource::SubChanset* release_channel();
  void set_allocated_channel(::KismetDatasource::SubChanset* channel);

  // optional string hardware = 6;
  bool has_hardware() const;
  void clear_hardware();
  static const int kHardwareFieldNumber = 6;
  const ::std::string& hardware() const;
  void set_hardware(const ::std::string& value);
  void set_hardware(const char* value);
  void set_hardware(const char* value, size_t size);
  ::std::string* mutable_hardware();
  ::std::string* release_hardware();
  void set_allocated_hardware(::std::string* hardware);

  // optional .KismetDatasource.SubMsgbus message = 7;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 7;
  const ::KismetDatasource::SubMsgbus& message() const;
  ::KismetDatasource::SubMsgbus* mutable_message();
  ::KismetDatasource::SubMsgbus* release_message();
  void set_allocated_message(::KismetDatasource::SubMsgbus* message);

  // optional .KismetDatasource.SubSpecset specset = 8;
  bool has_specset() const;
  void clear_specset();
  static const int kSpecsetFieldNumber = 8;
  const ::KismetDatasource::SubSpecset& specset() const;
  ::KismetDatasource::SubSpecset* mutable_specset();
  ::KismetDatasource::SubSpecset* release_specset();
  void set_allocated_specset(::KismetDatasource::SubSpecset* specset);

  // optional string uuid = 9;
  bool has_uuid() const;
  void clear_uuid();
  static const int kUuidFieldNumber = 9;
  const ::std::string& uuid() const;
  void set_uuid(const ::std::string& value);
  void set_uuid(const char* value);
  void set_uuid(const char* value, size_t size);
  ::std::string* mutable_uuid();
  ::std::string* release_uuid();
  void set_allocated_uuid(::std::string* uuid);

  // optional string warning = 10;
  bool has_warning() const;
  void clear_warning();
  static const int kWarningFieldNumber = 10;
  const ::std::string& warning() const;
  void set_warning(const ::std::string& value);
  void set_warning(const char* value);
  void set_warning(const char* value, size_t size);
  ::std::string* mutable_warning();
  ::std::string* release_warning();
  void set_allocated_warning(::std::string* warning);

  // @@protoc_insertion_point(class_scope:KismetDatasource.OpenSourceReport)
 private:
  inline void set_has_success();
  inline void clear_has_success();
  inline void set_has_dlt();
  inline void clear_has_dlt();
  inline void set_has_capture_interface();
  inline void clear_has_capture_interface();
  inline void set_has_channels();
  inline void clear_has_channels();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_hardware();
  inline void clear_has_hardware();
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_specset();
  inline void clear_has_specset();
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_warning();
  inline void clear_has_warning();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::KismetDatasource::SubSuccess* success_;
  ::google::protobuf::internal::ArenaStringPtr capture_interface_;
  ::KismetDatasource::SubChannels* channels_;
  ::KismetDatasource::SubChanset* channel_;
  ::google::protobuf::internal::ArenaStringPtr hardware_;
  ::KismetDatasource::SubMsgbus* message_;
  ::KismetDatasource::SubSpecset* specset_;
  ::google::protobuf::internal::ArenaStringPtr uuid_;
  ::google::protobuf::internal::ArenaStringPtr warning_;
  ::google::protobuf::uint32 dlt_;
  friend void  protobuf_AddDesc_datasource_2eproto();
  friend void protobuf_AssignDesc_datasource_2eproto();
  friend void protobuf_ShutdownFile_datasource_2eproto();

  void InitAsDefaultInstance();
  static OpenSourceReport* default_instance_;
};
// -------------------------------------------------------------------

class ProbeSource : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:KismetDatasource.ProbeSource) */ {
 public:
  ProbeSource();
  virtual ~ProbeSource();

  ProbeSource(const ProbeSource& from);

  inline ProbeSource& operator=(const ProbeSource& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProbeSource& default_instance();

  void Swap(ProbeSource* other);

  // implements Message ----------------------------------------------

  inline ProbeSource* New() const { return New(NULL); }

  ProbeSource* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProbeSource& from);
  void MergeFrom(const ProbeSource& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ProbeSource* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string definition = 1;
  bool has_definition() const;
  void clear_definition();
  static const int kDefinitionFieldNumber = 1;
  const ::std::string& definition() const;
  void set_definition(const ::std::string& value);
  void set_definition(const char* value);
  void set_definition(const char* value, size_t size);
  ::std::string* mutable_definition();
  ::std::string* release_definition();
  void set_allocated_definition(::std::string* definition);

  // @@protoc_insertion_point(class_scope:KismetDatasource.ProbeSource)
 private:
  inline void set_has_definition();
  inline void clear_has_definition();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr definition_;
  friend void  protobuf_AddDesc_datasource_2eproto();
  friend void protobuf_AssignDesc_datasource_2eproto();
  friend void protobuf_ShutdownFile_datasource_2eproto();

  void InitAsDefaultInstance();
  static ProbeSource* default_instance_;
};
// -------------------------------------------------------------------

class ProbeSourceReport : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:KismetDatasource.ProbeSourceReport) */ {
 public:
  ProbeSourceReport();
  virtual ~ProbeSourceReport();

  ProbeSourceReport(const ProbeSourceReport& from);

  inline ProbeSourceReport& operator=(const ProbeSourceReport& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProbeSourceReport& default_instance();

  void Swap(ProbeSourceReport* other);

  // implements Message ----------------------------------------------

  inline ProbeSourceReport* New() const { return New(NULL); }

  ProbeSourceReport* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProbeSourceReport& from);
  void MergeFrom(const ProbeSourceReport& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ProbeSourceReport* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .KismetDatasource.SubSuccess success = 1;
  bool has_success() const;
  void clear_success();
  static const int kSuccessFieldNumber = 1;
  const ::KismetDatasource::SubSuccess& success() const;
  ::KismetDatasource::SubSuccess* mutable_success();
  ::KismetDatasource::SubSuccess* release_success();
  void set_allocated_success(::KismetDatasource::SubSuccess* success);

  // optional .KismetDatasource.SubMsgbus message = 2;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::KismetDatasource::SubMsgbus& message() const;
  ::KismetDatasource::SubMsgbus* mutable_message();
  ::KismetDatasource::SubMsgbus* release_message();
  void set_allocated_message(::KismetDatasource::SubMsgbus* message);

  // optional .KismetDatasource.SubChannels channels = 3;
  bool has_channels() const;
  void clear_channels();
  static const int kChannelsFieldNumber = 3;
  const ::KismetDatasource::SubChannels& channels() const;
  ::KismetDatasource::SubChannels* mutable_channels();
  ::KismetDatasource::SubChannels* release_channels();
  void set_allocated_channels(::KismetDatasource::SubChannels* channels);

  // optional .KismetDatasource.SubChanset chanset = 4;
  bool has_chanset() const;
  void clear_chanset();
  static const int kChansetFieldNumber = 4;
  const ::KismetDatasource::SubChanset& chanset() const;
  ::KismetDatasource::SubChanset* mutable_chanset();
  ::KismetDatasource::SubChanset* release_chanset();
  void set_allocated_chanset(::KismetDatasource::SubChanset* chanset);

  // optional .KismetDatasource.SubSpecset specset = 5;
  bool has_specset() const;
  void clear_specset();
  static const int kSpecsetFieldNumber = 5;
  const ::KismetDatasource::SubSpecset& specset() const;
  ::KismetDatasource::SubSpecset* mutable_specset();
  ::KismetDatasource::SubSpecset* release_specset();
  void set_allocated_specset(::KismetDatasource::SubSpecset* specset);

  // optional string hardware = 6;
  bool has_hardware() const;
  void clear_hardware();
  static const int kHardwareFieldNumber = 6;
  const ::std::string& hardware() const;
  void set_hardware(const ::std::string& value);
  void set_hardware(const char* value);
  void set_hardware(const char* value, size_t size);
  ::std::string* mutable_hardware();
  ::std::string* release_hardware();
  void set_allocated_hardware(::std::string* hardware);

  // @@protoc_insertion_point(class_scope:KismetDatasource.ProbeSourceReport)
 private:
  inline void set_has_success();
  inline void clear_has_success();
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_channels();
  inline void clear_has_channels();
  inline void set_has_chanset();
  inline void clear_has_chanset();
  inline void set_has_specset();
  inline void clear_has_specset();
  inline void set_has_hardware();
  inline void clear_has_hardware();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::KismetDatasource::SubSuccess* success_;
  ::KismetDatasource::SubMsgbus* message_;
  ::KismetDatasource::SubChannels* channels_;
  ::KismetDatasource::SubChanset* chanset_;
  ::KismetDatasource::SubSpecset* specset_;
  ::google::protobuf::internal::ArenaStringPtr hardware_;
  friend void  protobuf_AddDesc_datasource_2eproto();
  friend void protobuf_AssignDesc_datasource_2eproto();
  friend void protobuf_ShutdownFile_datasource_2eproto();

  void InitAsDefaultInstance();
  static ProbeSourceReport* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// SubChannels

// repeated string channels = 1;
inline int SubChannels::channels_size() const {
  return channels_.size();
}
inline void SubChannels::clear_channels() {
  channels_.Clear();
}
inline const ::std::string& SubChannels::channels(int index) const {
  // @@protoc_insertion_point(field_get:KismetDatasource.SubChannels.channels)
  return channels_.Get(index);
}
inline ::std::string* SubChannels::mutable_channels(int index) {
  // @@protoc_insertion_point(field_mutable:KismetDatasource.SubChannels.channels)
  return channels_.Mutable(index);
}
inline void SubChannels::set_channels(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:KismetDatasource.SubChannels.channels)
  channels_.Mutable(index)->assign(value);
}
inline void SubChannels::set_channels(int index, const char* value) {
  channels_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:KismetDatasource.SubChannels.channels)
}
inline void SubChannels::set_channels(int index, const char* value, size_t size) {
  channels_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:KismetDatasource.SubChannels.channels)
}
inline ::std::string* SubChannels::add_channels() {
  // @@protoc_insertion_point(field_add_mutable:KismetDatasource.SubChannels.channels)
  return channels_.Add();
}
inline void SubChannels::add_channels(const ::std::string& value) {
  channels_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:KismetDatasource.SubChannels.channels)
}
inline void SubChannels::add_channels(const char* value) {
  channels_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:KismetDatasource.SubChannels.channels)
}
inline void SubChannels::add_channels(const char* value, size_t size) {
  channels_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:KismetDatasource.SubChannels.channels)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SubChannels::channels() const {
  // @@protoc_insertion_point(field_list:KismetDatasource.SubChannels.channels)
  return channels_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SubChannels::mutable_channels() {
  // @@protoc_insertion_point(field_mutable_list:KismetDatasource.SubChannels.channels)
  return &channels_;
}

// -------------------------------------------------------------------

// SubChanset

// required string channel = 1;
inline bool SubChanset::has_channel() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SubChanset::set_has_channel() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SubChanset::clear_has_channel() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SubChanset::clear_channel() {
  channel_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_channel();
}
inline const ::std::string& SubChanset::channel() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.SubChanset.channel)
  return channel_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubChanset::set_channel(const ::std::string& value) {
  set_has_channel();
  channel_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:KismetDatasource.SubChanset.channel)
}
inline void SubChanset::set_channel(const char* value) {
  set_has_channel();
  channel_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:KismetDatasource.SubChanset.channel)
}
inline void SubChanset::set_channel(const char* value, size_t size) {
  set_has_channel();
  channel_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:KismetDatasource.SubChanset.channel)
}
inline ::std::string* SubChanset::mutable_channel() {
  set_has_channel();
  // @@protoc_insertion_point(field_mutable:KismetDatasource.SubChanset.channel)
  return channel_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SubChanset::release_channel() {
  // @@protoc_insertion_point(field_release:KismetDatasource.SubChanset.channel)
  clear_has_channel();
  return channel_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubChanset::set_allocated_channel(::std::string* channel) {
  if (channel != NULL) {
    set_has_channel();
  } else {
    clear_has_channel();
  }
  channel_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), channel);
  // @@protoc_insertion_point(field_set_allocated:KismetDatasource.SubChanset.channel)
}

// -------------------------------------------------------------------

// SubChanhop

// repeated string channels = 1;
inline int SubChanhop::channels_size() const {
  return channels_.size();
}
inline void SubChanhop::clear_channels() {
  channels_.Clear();
}
inline const ::std::string& SubChanhop::channels(int index) const {
  // @@protoc_insertion_point(field_get:KismetDatasource.SubChanhop.channels)
  return channels_.Get(index);
}
inline ::std::string* SubChanhop::mutable_channels(int index) {
  // @@protoc_insertion_point(field_mutable:KismetDatasource.SubChanhop.channels)
  return channels_.Mutable(index);
}
inline void SubChanhop::set_channels(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:KismetDatasource.SubChanhop.channels)
  channels_.Mutable(index)->assign(value);
}
inline void SubChanhop::set_channels(int index, const char* value) {
  channels_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:KismetDatasource.SubChanhop.channels)
}
inline void SubChanhop::set_channels(int index, const char* value, size_t size) {
  channels_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:KismetDatasource.SubChanhop.channels)
}
inline ::std::string* SubChanhop::add_channels() {
  // @@protoc_insertion_point(field_add_mutable:KismetDatasource.SubChanhop.channels)
  return channels_.Add();
}
inline void SubChanhop::add_channels(const ::std::string& value) {
  channels_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:KismetDatasource.SubChanhop.channels)
}
inline void SubChanhop::add_channels(const char* value) {
  channels_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:KismetDatasource.SubChanhop.channels)
}
inline void SubChanhop::add_channels(const char* value, size_t size) {
  channels_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:KismetDatasource.SubChanhop.channels)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SubChanhop::channels() const {
  // @@protoc_insertion_point(field_list:KismetDatasource.SubChanhop.channels)
  return channels_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SubChanhop::mutable_channels() {
  // @@protoc_insertion_point(field_mutable_list:KismetDatasource.SubChanhop.channels)
  return &channels_;
}

// optional double rate = 2;
inline bool SubChanhop::has_rate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SubChanhop::set_has_rate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SubChanhop::clear_has_rate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SubChanhop::clear_rate() {
  rate_ = 0;
  clear_has_rate();
}
inline double SubChanhop::rate() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.SubChanhop.rate)
  return rate_;
}
inline void SubChanhop::set_rate(double value) {
  set_has_rate();
  rate_ = value;
  // @@protoc_insertion_point(field_set:KismetDatasource.SubChanhop.rate)
}

// optional bool shuffle = 3;
inline bool SubChanhop::has_shuffle() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SubChanhop::set_has_shuffle() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SubChanhop::clear_has_shuffle() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SubChanhop::clear_shuffle() {
  shuffle_ = false;
  clear_has_shuffle();
}
inline bool SubChanhop::shuffle() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.SubChanhop.shuffle)
  return shuffle_;
}
inline void SubChanhop::set_shuffle(bool value) {
  set_has_shuffle();
  shuffle_ = value;
  // @@protoc_insertion_point(field_set:KismetDatasource.SubChanhop.shuffle)
}

// optional uint32 shuffle_skip = 4;
inline bool SubChanhop::has_shuffle_skip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SubChanhop::set_has_shuffle_skip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SubChanhop::clear_has_shuffle_skip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SubChanhop::clear_shuffle_skip() {
  shuffle_skip_ = 0u;
  clear_has_shuffle_skip();
}
inline ::google::protobuf::uint32 SubChanhop::shuffle_skip() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.SubChanhop.shuffle_skip)
  return shuffle_skip_;
}
inline void SubChanhop::set_shuffle_skip(::google::protobuf::uint32 value) {
  set_has_shuffle_skip();
  shuffle_skip_ = value;
  // @@protoc_insertion_point(field_set:KismetDatasource.SubChanhop.shuffle_skip)
}

// optional uint32 offset = 5;
inline bool SubChanhop::has_offset() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SubChanhop::set_has_offset() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SubChanhop::clear_has_offset() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SubChanhop::clear_offset() {
  offset_ = 0u;
  clear_has_offset();
}
inline ::google::protobuf::uint32 SubChanhop::offset() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.SubChanhop.offset)
  return offset_;
}
inline void SubChanhop::set_offset(::google::protobuf::uint32 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:KismetDatasource.SubChanhop.offset)
}

// -------------------------------------------------------------------

// SubGps

// required double lat = 1;
inline bool SubGps::has_lat() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SubGps::set_has_lat() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SubGps::clear_has_lat() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SubGps::clear_lat() {
  lat_ = 0;
  clear_has_lat();
}
inline double SubGps::lat() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.SubGps.lat)
  return lat_;
}
inline void SubGps::set_lat(double value) {
  set_has_lat();
  lat_ = value;
  // @@protoc_insertion_point(field_set:KismetDatasource.SubGps.lat)
}

// required double lon = 2;
inline bool SubGps::has_lon() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SubGps::set_has_lon() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SubGps::clear_has_lon() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SubGps::clear_lon() {
  lon_ = 0;
  clear_has_lon();
}
inline double SubGps::lon() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.SubGps.lon)
  return lon_;
}
inline void SubGps::set_lon(double value) {
  set_has_lon();
  lon_ = value;
  // @@protoc_insertion_point(field_set:KismetDatasource.SubGps.lon)
}

// required double alt = 3;
inline bool SubGps::has_alt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SubGps::set_has_alt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SubGps::clear_has_alt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SubGps::clear_alt() {
  alt_ = 0;
  clear_has_alt();
}
inline double SubGps::alt() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.SubGps.alt)
  return alt_;
}
inline void SubGps::set_alt(double value) {
  set_has_alt();
  alt_ = value;
  // @@protoc_insertion_point(field_set:KismetDatasource.SubGps.alt)
}

// required double speed = 4;
inline bool SubGps::has_speed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SubGps::set_has_speed() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SubGps::clear_has_speed() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SubGps::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline double SubGps::speed() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.SubGps.speed)
  return speed_;
}
inline void SubGps::set_speed(double value) {
  set_has_speed();
  speed_ = value;
  // @@protoc_insertion_point(field_set:KismetDatasource.SubGps.speed)
}

// required double heading = 5;
inline bool SubGps::has_heading() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SubGps::set_has_heading() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SubGps::clear_has_heading() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SubGps::clear_heading() {
  heading_ = 0;
  clear_has_heading();
}
inline double SubGps::heading() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.SubGps.heading)
  return heading_;
}
inline void SubGps::set_heading(double value) {
  set_has_heading();
  heading_ = value;
  // @@protoc_insertion_point(field_set:KismetDatasource.SubGps.heading)
}

// required double precision = 6;
inline bool SubGps::has_precision() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SubGps::set_has_precision() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SubGps::clear_has_precision() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SubGps::clear_precision() {
  precision_ = 0;
  clear_has_precision();
}
inline double SubGps::precision() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.SubGps.precision)
  return precision_;
}
inline void SubGps::set_precision(double value) {
  set_has_precision();
  precision_ = value;
  // @@protoc_insertion_point(field_set:KismetDatasource.SubGps.precision)
}

// required uint32 fix = 7;
inline bool SubGps::has_fix() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SubGps::set_has_fix() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SubGps::clear_has_fix() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SubGps::clear_fix() {
  fix_ = 0u;
  clear_has_fix();
}
inline ::google::protobuf::uint32 SubGps::fix() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.SubGps.fix)
  return fix_;
}
inline void SubGps::set_fix(::google::protobuf::uint32 value) {
  set_has_fix();
  fix_ = value;
  // @@protoc_insertion_point(field_set:KismetDatasource.SubGps.fix)
}

// required uint64 time_sec = 8;
inline bool SubGps::has_time_sec() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SubGps::set_has_time_sec() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SubGps::clear_has_time_sec() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SubGps::clear_time_sec() {
  time_sec_ = GOOGLE_ULONGLONG(0);
  clear_has_time_sec();
}
inline ::google::protobuf::uint64 SubGps::time_sec() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.SubGps.time_sec)
  return time_sec_;
}
inline void SubGps::set_time_sec(::google::protobuf::uint64 value) {
  set_has_time_sec();
  time_sec_ = value;
  // @@protoc_insertion_point(field_set:KismetDatasource.SubGps.time_sec)
}

// required uint64 time_usec = 9;
inline bool SubGps::has_time_usec() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SubGps::set_has_time_usec() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SubGps::clear_has_time_usec() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SubGps::clear_time_usec() {
  time_usec_ = GOOGLE_ULONGLONG(0);
  clear_has_time_usec();
}
inline ::google::protobuf::uint64 SubGps::time_usec() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.SubGps.time_usec)
  return time_usec_;
}
inline void SubGps::set_time_usec(::google::protobuf::uint64 value) {
  set_has_time_usec();
  time_usec_ = value;
  // @@protoc_insertion_point(field_set:KismetDatasource.SubGps.time_usec)
}

// required string type = 10;
inline bool SubGps::has_type() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SubGps::set_has_type() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SubGps::clear_has_type() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SubGps::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type();
}
inline const ::std::string& SubGps::type() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.SubGps.type)
  return type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubGps::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:KismetDatasource.SubGps.type)
}
inline void SubGps::set_type(const char* value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:KismetDatasource.SubGps.type)
}
inline void SubGps::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:KismetDatasource.SubGps.type)
}
inline ::std::string* SubGps::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:KismetDatasource.SubGps.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SubGps::release_type() {
  // @@protoc_insertion_point(field_release:KismetDatasource.SubGps.type)
  clear_has_type();
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubGps::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:KismetDatasource.SubGps.type)
}

// required string name = 11;
inline bool SubGps::has_name() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SubGps::set_has_name() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SubGps::clear_has_name() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SubGps::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& SubGps::name() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.SubGps.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubGps::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:KismetDatasource.SubGps.name)
}
inline void SubGps::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:KismetDatasource.SubGps.name)
}
inline void SubGps::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:KismetDatasource.SubGps.name)
}
inline ::std::string* SubGps::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:KismetDatasource.SubGps.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SubGps::release_name() {
  // @@protoc_insertion_point(field_release:KismetDatasource.SubGps.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubGps::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:KismetDatasource.SubGps.name)
}

// -------------------------------------------------------------------

// SubInterface

// required string interface = 1;
inline bool SubInterface::has_interface() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SubInterface::set_has_interface() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SubInterface::clear_has_interface() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SubInterface::clear_interface() {
  interface_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_interface();
}
inline const ::std::string& SubInterface::interface() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.SubInterface.interface)
  return interface_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubInterface::set_interface(const ::std::string& value) {
  set_has_interface();
  interface_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:KismetDatasource.SubInterface.interface)
}
inline void SubInterface::set_interface(const char* value) {
  set_has_interface();
  interface_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:KismetDatasource.SubInterface.interface)
}
inline void SubInterface::set_interface(const char* value, size_t size) {
  set_has_interface();
  interface_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:KismetDatasource.SubInterface.interface)
}
inline ::std::string* SubInterface::mutable_interface() {
  set_has_interface();
  // @@protoc_insertion_point(field_mutable:KismetDatasource.SubInterface.interface)
  return interface_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SubInterface::release_interface() {
  // @@protoc_insertion_point(field_release:KismetDatasource.SubInterface.interface)
  clear_has_interface();
  return interface_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubInterface::set_allocated_interface(::std::string* interface) {
  if (interface != NULL) {
    set_has_interface();
  } else {
    clear_has_interface();
  }
  interface_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), interface);
  // @@protoc_insertion_point(field_set_allocated:KismetDatasource.SubInterface.interface)
}

// required string flags = 2;
inline bool SubInterface::has_flags() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SubInterface::set_has_flags() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SubInterface::clear_has_flags() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SubInterface::clear_flags() {
  flags_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_flags();
}
inline const ::std::string& SubInterface::flags() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.SubInterface.flags)
  return flags_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubInterface::set_flags(const ::std::string& value) {
  set_has_flags();
  flags_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:KismetDatasource.SubInterface.flags)
}
inline void SubInterface::set_flags(const char* value) {
  set_has_flags();
  flags_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:KismetDatasource.SubInterface.flags)
}
inline void SubInterface::set_flags(const char* value, size_t size) {
  set_has_flags();
  flags_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:KismetDatasource.SubInterface.flags)
}
inline ::std::string* SubInterface::mutable_flags() {
  set_has_flags();
  // @@protoc_insertion_point(field_mutable:KismetDatasource.SubInterface.flags)
  return flags_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SubInterface::release_flags() {
  // @@protoc_insertion_point(field_release:KismetDatasource.SubInterface.flags)
  clear_has_flags();
  return flags_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubInterface::set_allocated_flags(::std::string* flags) {
  if (flags != NULL) {
    set_has_flags();
  } else {
    clear_has_flags();
  }
  flags_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), flags);
  // @@protoc_insertion_point(field_set_allocated:KismetDatasource.SubInterface.flags)
}

// optional string hardware = 3;
inline bool SubInterface::has_hardware() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SubInterface::set_has_hardware() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SubInterface::clear_has_hardware() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SubInterface::clear_hardware() {
  hardware_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hardware();
}
inline const ::std::string& SubInterface::hardware() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.SubInterface.hardware)
  return hardware_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubInterface::set_hardware(const ::std::string& value) {
  set_has_hardware();
  hardware_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:KismetDatasource.SubInterface.hardware)
}
inline void SubInterface::set_hardware(const char* value) {
  set_has_hardware();
  hardware_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:KismetDatasource.SubInterface.hardware)
}
inline void SubInterface::set_hardware(const char* value, size_t size) {
  set_has_hardware();
  hardware_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:KismetDatasource.SubInterface.hardware)
}
inline ::std::string* SubInterface::mutable_hardware() {
  set_has_hardware();
  // @@protoc_insertion_point(field_mutable:KismetDatasource.SubInterface.hardware)
  return hardware_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SubInterface::release_hardware() {
  // @@protoc_insertion_point(field_release:KismetDatasource.SubInterface.hardware)
  clear_has_hardware();
  return hardware_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubInterface::set_allocated_hardware(::std::string* hardware) {
  if (hardware != NULL) {
    set_has_hardware();
  } else {
    clear_has_hardware();
  }
  hardware_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hardware);
  // @@protoc_insertion_point(field_set_allocated:KismetDatasource.SubInterface.hardware)
}

// -------------------------------------------------------------------

// SubMsgbus

// required .KismetDatasource.SubMsgbus.MessageType msgtype = 1;
inline bool SubMsgbus::has_msgtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SubMsgbus::set_has_msgtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SubMsgbus::clear_has_msgtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SubMsgbus::clear_msgtype() {
  msgtype_ = 1;
  clear_has_msgtype();
}
inline ::KismetDatasource::SubMsgbus_MessageType SubMsgbus::msgtype() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.SubMsgbus.msgtype)
  return static_cast< ::KismetDatasource::SubMsgbus_MessageType >(msgtype_);
}
inline void SubMsgbus::set_msgtype(::KismetDatasource::SubMsgbus_MessageType value) {
  assert(::KismetDatasource::SubMsgbus_MessageType_IsValid(value));
  set_has_msgtype();
  msgtype_ = value;
  // @@protoc_insertion_point(field_set:KismetDatasource.SubMsgbus.msgtype)
}

// required string msgtext = 2;
inline bool SubMsgbus::has_msgtext() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SubMsgbus::set_has_msgtext() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SubMsgbus::clear_has_msgtext() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SubMsgbus::clear_msgtext() {
  msgtext_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_msgtext();
}
inline const ::std::string& SubMsgbus::msgtext() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.SubMsgbus.msgtext)
  return msgtext_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubMsgbus::set_msgtext(const ::std::string& value) {
  set_has_msgtext();
  msgtext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:KismetDatasource.SubMsgbus.msgtext)
}
inline void SubMsgbus::set_msgtext(const char* value) {
  set_has_msgtext();
  msgtext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:KismetDatasource.SubMsgbus.msgtext)
}
inline void SubMsgbus::set_msgtext(const char* value, size_t size) {
  set_has_msgtext();
  msgtext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:KismetDatasource.SubMsgbus.msgtext)
}
inline ::std::string* SubMsgbus::mutable_msgtext() {
  set_has_msgtext();
  // @@protoc_insertion_point(field_mutable:KismetDatasource.SubMsgbus.msgtext)
  return msgtext_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SubMsgbus::release_msgtext() {
  // @@protoc_insertion_point(field_release:KismetDatasource.SubMsgbus.msgtext)
  clear_has_msgtext();
  return msgtext_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubMsgbus::set_allocated_msgtext(::std::string* msgtext) {
  if (msgtext != NULL) {
    set_has_msgtext();
  } else {
    clear_has_msgtext();
  }
  msgtext_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), msgtext);
  // @@protoc_insertion_point(field_set_allocated:KismetDatasource.SubMsgbus.msgtext)
}

// -------------------------------------------------------------------

// SubPacket

// required uint64 time_sec = 1;
inline bool SubPacket::has_time_sec() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SubPacket::set_has_time_sec() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SubPacket::clear_has_time_sec() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SubPacket::clear_time_sec() {
  time_sec_ = GOOGLE_ULONGLONG(0);
  clear_has_time_sec();
}
inline ::google::protobuf::uint64 SubPacket::time_sec() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.SubPacket.time_sec)
  return time_sec_;
}
inline void SubPacket::set_time_sec(::google::protobuf::uint64 value) {
  set_has_time_sec();
  time_sec_ = value;
  // @@protoc_insertion_point(field_set:KismetDatasource.SubPacket.time_sec)
}

// required uint64 time_usec = 2;
inline bool SubPacket::has_time_usec() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SubPacket::set_has_time_usec() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SubPacket::clear_has_time_usec() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SubPacket::clear_time_usec() {
  time_usec_ = GOOGLE_ULONGLONG(0);
  clear_has_time_usec();
}
inline ::google::protobuf::uint64 SubPacket::time_usec() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.SubPacket.time_usec)
  return time_usec_;
}
inline void SubPacket::set_time_usec(::google::protobuf::uint64 value) {
  set_has_time_usec();
  time_usec_ = value;
  // @@protoc_insertion_point(field_set:KismetDatasource.SubPacket.time_usec)
}

// required uint32 dlt = 3;
inline bool SubPacket::has_dlt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SubPacket::set_has_dlt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SubPacket::clear_has_dlt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SubPacket::clear_dlt() {
  dlt_ = 0u;
  clear_has_dlt();
}
inline ::google::protobuf::uint32 SubPacket::dlt() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.SubPacket.dlt)
  return dlt_;
}
inline void SubPacket::set_dlt(::google::protobuf::uint32 value) {
  set_has_dlt();
  dlt_ = value;
  // @@protoc_insertion_point(field_set:KismetDatasource.SubPacket.dlt)
}

// required uint64 size = 4;
inline bool SubPacket::has_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SubPacket::set_has_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SubPacket::clear_has_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SubPacket::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::uint64 SubPacket::size() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.SubPacket.size)
  return size_;
}
inline void SubPacket::set_size(::google::protobuf::uint64 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:KismetDatasource.SubPacket.size)
}

// required bytes data = 5;
inline bool SubPacket::has_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SubPacket::set_has_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SubPacket::clear_has_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SubPacket::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
inline const ::std::string& SubPacket::data() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.SubPacket.data)
  return data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubPacket::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:KismetDatasource.SubPacket.data)
}
inline void SubPacket::set_data(const char* value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:KismetDatasource.SubPacket.data)
}
inline void SubPacket::set_data(const void* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:KismetDatasource.SubPacket.data)
}
inline ::std::string* SubPacket::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:KismetDatasource.SubPacket.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SubPacket::release_data() {
  // @@protoc_insertion_point(field_release:KismetDatasource.SubPacket.data)
  clear_has_data();
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubPacket::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:KismetDatasource.SubPacket.data)
}

// -------------------------------------------------------------------

// SubSignal

// optional double signal_dbm = 1;
inline bool SubSignal::has_signal_dbm() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SubSignal::set_has_signal_dbm() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SubSignal::clear_has_signal_dbm() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SubSignal::clear_signal_dbm() {
  signal_dbm_ = 0;
  clear_has_signal_dbm();
}
inline double SubSignal::signal_dbm() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.SubSignal.signal_dbm)
  return signal_dbm_;
}
inline void SubSignal::set_signal_dbm(double value) {
  set_has_signal_dbm();
  signal_dbm_ = value;
  // @@protoc_insertion_point(field_set:KismetDatasource.SubSignal.signal_dbm)
}

// optional double noise_dbm = 2;
inline bool SubSignal::has_noise_dbm() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SubSignal::set_has_noise_dbm() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SubSignal::clear_has_noise_dbm() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SubSignal::clear_noise_dbm() {
  noise_dbm_ = 0;
  clear_has_noise_dbm();
}
inline double SubSignal::noise_dbm() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.SubSignal.noise_dbm)
  return noise_dbm_;
}
inline void SubSignal::set_noise_dbm(double value) {
  set_has_noise_dbm();
  noise_dbm_ = value;
  // @@protoc_insertion_point(field_set:KismetDatasource.SubSignal.noise_dbm)
}

// optional double signal_rssi = 3;
inline bool SubSignal::has_signal_rssi() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SubSignal::set_has_signal_rssi() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SubSignal::clear_has_signal_rssi() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SubSignal::clear_signal_rssi() {
  signal_rssi_ = 0;
  clear_has_signal_rssi();
}
inline double SubSignal::signal_rssi() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.SubSignal.signal_rssi)
  return signal_rssi_;
}
inline void SubSignal::set_signal_rssi(double value) {
  set_has_signal_rssi();
  signal_rssi_ = value;
  // @@protoc_insertion_point(field_set:KismetDatasource.SubSignal.signal_rssi)
}

// optional double noise_rssi = 4;
inline bool SubSignal::has_noise_rssi() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SubSignal::set_has_noise_rssi() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SubSignal::clear_has_noise_rssi() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SubSignal::clear_noise_rssi() {
  noise_rssi_ = 0;
  clear_has_noise_rssi();
}
inline double SubSignal::noise_rssi() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.SubSignal.noise_rssi)
  return noise_rssi_;
}
inline void SubSignal::set_noise_rssi(double value) {
  set_has_noise_rssi();
  noise_rssi_ = value;
  // @@protoc_insertion_point(field_set:KismetDatasource.SubSignal.noise_rssi)
}

// optional double freq_khz = 5;
inline bool SubSignal::has_freq_khz() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SubSignal::set_has_freq_khz() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SubSignal::clear_has_freq_khz() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SubSignal::clear_freq_khz() {
  freq_khz_ = 0;
  clear_has_freq_khz();
}
inline double SubSignal::freq_khz() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.SubSignal.freq_khz)
  return freq_khz_;
}
inline void SubSignal::set_freq_khz(double value) {
  set_has_freq_khz();
  freq_khz_ = value;
  // @@protoc_insertion_point(field_set:KismetDatasource.SubSignal.freq_khz)
}

// optional string channel = 6;
inline bool SubSignal::has_channel() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SubSignal::set_has_channel() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SubSignal::clear_has_channel() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SubSignal::clear_channel() {
  channel_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_channel();
}
inline const ::std::string& SubSignal::channel() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.SubSignal.channel)
  return channel_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubSignal::set_channel(const ::std::string& value) {
  set_has_channel();
  channel_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:KismetDatasource.SubSignal.channel)
}
inline void SubSignal::set_channel(const char* value) {
  set_has_channel();
  channel_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:KismetDatasource.SubSignal.channel)
}
inline void SubSignal::set_channel(const char* value, size_t size) {
  set_has_channel();
  channel_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:KismetDatasource.SubSignal.channel)
}
inline ::std::string* SubSignal::mutable_channel() {
  set_has_channel();
  // @@protoc_insertion_point(field_mutable:KismetDatasource.SubSignal.channel)
  return channel_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SubSignal::release_channel() {
  // @@protoc_insertion_point(field_release:KismetDatasource.SubSignal.channel)
  clear_has_channel();
  return channel_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubSignal::set_allocated_channel(::std::string* channel) {
  if (channel != NULL) {
    set_has_channel();
  } else {
    clear_has_channel();
  }
  channel_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), channel);
  // @@protoc_insertion_point(field_set_allocated:KismetDatasource.SubSignal.channel)
}

// optional double datarate = 7;
inline bool SubSignal::has_datarate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SubSignal::set_has_datarate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SubSignal::clear_has_datarate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SubSignal::clear_datarate() {
  datarate_ = 0;
  clear_has_datarate();
}
inline double SubSignal::datarate() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.SubSignal.datarate)
  return datarate_;
}
inline void SubSignal::set_datarate(double value) {
  set_has_datarate();
  datarate_ = value;
  // @@protoc_insertion_point(field_set:KismetDatasource.SubSignal.datarate)
}

// -------------------------------------------------------------------

// SubSpecset

// optional double start_mhz = 1;
inline bool SubSpecset::has_start_mhz() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SubSpecset::set_has_start_mhz() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SubSpecset::clear_has_start_mhz() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SubSpecset::clear_start_mhz() {
  start_mhz_ = 0;
  clear_has_start_mhz();
}
inline double SubSpecset::start_mhz() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.SubSpecset.start_mhz)
  return start_mhz_;
}
inline void SubSpecset::set_start_mhz(double value) {
  set_has_start_mhz();
  start_mhz_ = value;
  // @@protoc_insertion_point(field_set:KismetDatasource.SubSpecset.start_mhz)
}

// optional double end_mhz = 2;
inline bool SubSpecset::has_end_mhz() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SubSpecset::set_has_end_mhz() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SubSpecset::clear_has_end_mhz() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SubSpecset::clear_end_mhz() {
  end_mhz_ = 0;
  clear_has_end_mhz();
}
inline double SubSpecset::end_mhz() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.SubSpecset.end_mhz)
  return end_mhz_;
}
inline void SubSpecset::set_end_mhz(double value) {
  set_has_end_mhz();
  end_mhz_ = value;
  // @@protoc_insertion_point(field_set:KismetDatasource.SubSpecset.end_mhz)
}

// optional double samples_per_bucket = 3;
inline bool SubSpecset::has_samples_per_bucket() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SubSpecset::set_has_samples_per_bucket() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SubSpecset::clear_has_samples_per_bucket() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SubSpecset::clear_samples_per_bucket() {
  samples_per_bucket_ = 0;
  clear_has_samples_per_bucket();
}
inline double SubSpecset::samples_per_bucket() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.SubSpecset.samples_per_bucket)
  return samples_per_bucket_;
}
inline void SubSpecset::set_samples_per_bucket(double value) {
  set_has_samples_per_bucket();
  samples_per_bucket_ = value;
  // @@protoc_insertion_point(field_set:KismetDatasource.SubSpecset.samples_per_bucket)
}

// optional double bucket_width_hz = 4;
inline bool SubSpecset::has_bucket_width_hz() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SubSpecset::set_has_bucket_width_hz() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SubSpecset::clear_has_bucket_width_hz() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SubSpecset::clear_bucket_width_hz() {
  bucket_width_hz_ = 0;
  clear_has_bucket_width_hz();
}
inline double SubSpecset::bucket_width_hz() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.SubSpecset.bucket_width_hz)
  return bucket_width_hz_;
}
inline void SubSpecset::set_bucket_width_hz(double value) {
  set_has_bucket_width_hz();
  bucket_width_hz_ = value;
  // @@protoc_insertion_point(field_set:KismetDatasource.SubSpecset.bucket_width_hz)
}

// optional bool enable_amp = 5;
inline bool SubSpecset::has_enable_amp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SubSpecset::set_has_enable_amp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SubSpecset::clear_has_enable_amp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SubSpecset::clear_enable_amp() {
  enable_amp_ = false;
  clear_has_enable_amp();
}
inline bool SubSpecset::enable_amp() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.SubSpecset.enable_amp)
  return enable_amp_;
}
inline void SubSpecset::set_enable_amp(bool value) {
  set_has_enable_amp();
  enable_amp_ = value;
  // @@protoc_insertion_point(field_set:KismetDatasource.SubSpecset.enable_amp)
}

// optional uint64 if_amp = 6;
inline bool SubSpecset::has_if_amp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SubSpecset::set_has_if_amp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SubSpecset::clear_has_if_amp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SubSpecset::clear_if_amp() {
  if_amp_ = GOOGLE_ULONGLONG(0);
  clear_has_if_amp();
}
inline ::google::protobuf::uint64 SubSpecset::if_amp() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.SubSpecset.if_amp)
  return if_amp_;
}
inline void SubSpecset::set_if_amp(::google::protobuf::uint64 value) {
  set_has_if_amp();
  if_amp_ = value;
  // @@protoc_insertion_point(field_set:KismetDatasource.SubSpecset.if_amp)
}

// optional uint64 baseband_amp = 7;
inline bool SubSpecset::has_baseband_amp() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SubSpecset::set_has_baseband_amp() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SubSpecset::clear_has_baseband_amp() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SubSpecset::clear_baseband_amp() {
  baseband_amp_ = GOOGLE_ULONGLONG(0);
  clear_has_baseband_amp();
}
inline ::google::protobuf::uint64 SubSpecset::baseband_amp() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.SubSpecset.baseband_amp)
  return baseband_amp_;
}
inline void SubSpecset::set_baseband_amp(::google::protobuf::uint64 value) {
  set_has_baseband_amp();
  baseband_amp_ = value;
  // @@protoc_insertion_point(field_set:KismetDatasource.SubSpecset.baseband_amp)
}

// -------------------------------------------------------------------

// SubSpectrum

// optional uint64 time_sec = 1;
inline bool SubSpectrum::has_time_sec() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SubSpectrum::set_has_time_sec() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SubSpectrum::clear_has_time_sec() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SubSpectrum::clear_time_sec() {
  time_sec_ = GOOGLE_ULONGLONG(0);
  clear_has_time_sec();
}
inline ::google::protobuf::uint64 SubSpectrum::time_sec() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.SubSpectrum.time_sec)
  return time_sec_;
}
inline void SubSpectrum::set_time_sec(::google::protobuf::uint64 value) {
  set_has_time_sec();
  time_sec_ = value;
  // @@protoc_insertion_point(field_set:KismetDatasource.SubSpectrum.time_sec)
}

// optional uint64 time_usec = 2;
inline bool SubSpectrum::has_time_usec() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SubSpectrum::set_has_time_usec() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SubSpectrum::clear_has_time_usec() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SubSpectrum::clear_time_usec() {
  time_usec_ = GOOGLE_ULONGLONG(0);
  clear_has_time_usec();
}
inline ::google::protobuf::uint64 SubSpectrum::time_usec() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.SubSpectrum.time_usec)
  return time_usec_;
}
inline void SubSpectrum::set_time_usec(::google::protobuf::uint64 value) {
  set_has_time_usec();
  time_usec_ = value;
  // @@protoc_insertion_point(field_set:KismetDatasource.SubSpectrum.time_usec)
}

// optional double start_mhz = 3;
inline bool SubSpectrum::has_start_mhz() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SubSpectrum::set_has_start_mhz() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SubSpectrum::clear_has_start_mhz() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SubSpectrum::clear_start_mhz() {
  start_mhz_ = 0;
  clear_has_start_mhz();
}
inline double SubSpectrum::start_mhz() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.SubSpectrum.start_mhz)
  return start_mhz_;
}
inline void SubSpectrum::set_start_mhz(double value) {
  set_has_start_mhz();
  start_mhz_ = value;
  // @@protoc_insertion_point(field_set:KismetDatasource.SubSpectrum.start_mhz)
}

// optional double end_mhz = 4;
inline bool SubSpectrum::has_end_mhz() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SubSpectrum::set_has_end_mhz() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SubSpectrum::clear_has_end_mhz() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SubSpectrum::clear_end_mhz() {
  end_mhz_ = 0;
  clear_has_end_mhz();
}
inline double SubSpectrum::end_mhz() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.SubSpectrum.end_mhz)
  return end_mhz_;
}
inline void SubSpectrum::set_end_mhz(double value) {
  set_has_end_mhz();
  end_mhz_ = value;
  // @@protoc_insertion_point(field_set:KismetDatasource.SubSpectrum.end_mhz)
}

// optional double bucket_width_hz = 5;
inline bool SubSpectrum::has_bucket_width_hz() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SubSpectrum::set_has_bucket_width_hz() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SubSpectrum::clear_has_bucket_width_hz() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SubSpectrum::clear_bucket_width_hz() {
  bucket_width_hz_ = 0;
  clear_has_bucket_width_hz();
}
inline double SubSpectrum::bucket_width_hz() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.SubSpectrum.bucket_width_hz)
  return bucket_width_hz_;
}
inline void SubSpectrum::set_bucket_width_hz(double value) {
  set_has_bucket_width_hz();
  bucket_width_hz_ = value;
  // @@protoc_insertion_point(field_set:KismetDatasource.SubSpectrum.bucket_width_hz)
}

// repeated int32 data = 6;
inline int SubSpectrum::data_size() const {
  return data_.size();
}
inline void SubSpectrum::clear_data() {
  data_.Clear();
}
inline ::google::protobuf::int32 SubSpectrum::data(int index) const {
  // @@protoc_insertion_point(field_get:KismetDatasource.SubSpectrum.data)
  return data_.Get(index);
}
inline void SubSpectrum::set_data(int index, ::google::protobuf::int32 value) {
  data_.Set(index, value);
  // @@protoc_insertion_point(field_set:KismetDatasource.SubSpectrum.data)
}
inline void SubSpectrum::add_data(::google::protobuf::int32 value) {
  data_.Add(value);
  // @@protoc_insertion_point(field_add:KismetDatasource.SubSpectrum.data)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
SubSpectrum::data() const {
  // @@protoc_insertion_point(field_list:KismetDatasource.SubSpectrum.data)
  return data_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
SubSpectrum::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:KismetDatasource.SubSpectrum.data)
  return &data_;
}

// -------------------------------------------------------------------

// SubSuccess

// required bool success = 1;
inline bool SubSuccess::has_success() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SubSuccess::set_has_success() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SubSuccess::clear_has_success() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SubSuccess::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool SubSuccess::success() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.SubSuccess.success)
  return success_;
}
inline void SubSuccess::set_success(bool value) {
  set_has_success();
  success_ = value;
  // @@protoc_insertion_point(field_set:KismetDatasource.SubSuccess.success)
}

// required uint32 command_num = 2;
inline bool SubSuccess::has_command_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SubSuccess::set_has_command_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SubSuccess::clear_has_command_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SubSuccess::clear_command_num() {
  command_num_ = 0u;
  clear_has_command_num();
}
inline ::google::protobuf::uint32 SubSuccess::command_num() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.SubSuccess.command_num)
  return command_num_;
}
inline void SubSuccess::set_command_num(::google::protobuf::uint32 value) {
  set_has_command_num();
  command_num_ = value;
  // @@protoc_insertion_point(field_set:KismetDatasource.SubSuccess.command_num)
}

// -------------------------------------------------------------------

// Channels

// required .KismetDatasource.SubChannels channels = 1;
inline bool Channels::has_channels() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Channels::set_has_channels() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Channels::clear_has_channels() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Channels::clear_channels() {
  if (channels_ != NULL) channels_->::KismetDatasource::SubChannels::Clear();
  clear_has_channels();
}
inline const ::KismetDatasource::SubChannels& Channels::channels() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.Channels.channels)
  return channels_ != NULL ? *channels_ : *default_instance_->channels_;
}
inline ::KismetDatasource::SubChannels* Channels::mutable_channels() {
  set_has_channels();
  if (channels_ == NULL) {
    channels_ = new ::KismetDatasource::SubChannels;
  }
  // @@protoc_insertion_point(field_mutable:KismetDatasource.Channels.channels)
  return channels_;
}
inline ::KismetDatasource::SubChannels* Channels::release_channels() {
  // @@protoc_insertion_point(field_release:KismetDatasource.Channels.channels)
  clear_has_channels();
  ::KismetDatasource::SubChannels* temp = channels_;
  channels_ = NULL;
  return temp;
}
inline void Channels::set_allocated_channels(::KismetDatasource::SubChannels* channels) {
  delete channels_;
  channels_ = channels;
  if (channels) {
    set_has_channels();
  } else {
    clear_has_channels();
  }
  // @@protoc_insertion_point(field_set_allocated:KismetDatasource.Channels.channels)
}

// -------------------------------------------------------------------

// CloseDatasource

// -------------------------------------------------------------------

// Configure

// optional .KismetDatasource.SubChanset channel = 1;
inline bool Configure::has_channel() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Configure::set_has_channel() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Configure::clear_has_channel() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Configure::clear_channel() {
  if (channel_ != NULL) channel_->::KismetDatasource::SubChanset::Clear();
  clear_has_channel();
}
inline const ::KismetDatasource::SubChanset& Configure::channel() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.Configure.channel)
  return channel_ != NULL ? *channel_ : *default_instance_->channel_;
}
inline ::KismetDatasource::SubChanset* Configure::mutable_channel() {
  set_has_channel();
  if (channel_ == NULL) {
    channel_ = new ::KismetDatasource::SubChanset;
  }
  // @@protoc_insertion_point(field_mutable:KismetDatasource.Configure.channel)
  return channel_;
}
inline ::KismetDatasource::SubChanset* Configure::release_channel() {
  // @@protoc_insertion_point(field_release:KismetDatasource.Configure.channel)
  clear_has_channel();
  ::KismetDatasource::SubChanset* temp = channel_;
  channel_ = NULL;
  return temp;
}
inline void Configure::set_allocated_channel(::KismetDatasource::SubChanset* channel) {
  delete channel_;
  channel_ = channel;
  if (channel) {
    set_has_channel();
  } else {
    clear_has_channel();
  }
  // @@protoc_insertion_point(field_set_allocated:KismetDatasource.Configure.channel)
}

// optional .KismetDatasource.SubChanhop hopping = 2;
inline bool Configure::has_hopping() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Configure::set_has_hopping() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Configure::clear_has_hopping() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Configure::clear_hopping() {
  if (hopping_ != NULL) hopping_->::KismetDatasource::SubChanhop::Clear();
  clear_has_hopping();
}
inline const ::KismetDatasource::SubChanhop& Configure::hopping() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.Configure.hopping)
  return hopping_ != NULL ? *hopping_ : *default_instance_->hopping_;
}
inline ::KismetDatasource::SubChanhop* Configure::mutable_hopping() {
  set_has_hopping();
  if (hopping_ == NULL) {
    hopping_ = new ::KismetDatasource::SubChanhop;
  }
  // @@protoc_insertion_point(field_mutable:KismetDatasource.Configure.hopping)
  return hopping_;
}
inline ::KismetDatasource::SubChanhop* Configure::release_hopping() {
  // @@protoc_insertion_point(field_release:KismetDatasource.Configure.hopping)
  clear_has_hopping();
  ::KismetDatasource::SubChanhop* temp = hopping_;
  hopping_ = NULL;
  return temp;
}
inline void Configure::set_allocated_hopping(::KismetDatasource::SubChanhop* hopping) {
  delete hopping_;
  hopping_ = hopping;
  if (hopping) {
    set_has_hopping();
  } else {
    clear_has_hopping();
  }
  // @@protoc_insertion_point(field_set_allocated:KismetDatasource.Configure.hopping)
}

// optional .KismetDatasource.SubSpecset spectrum = 3;
inline bool Configure::has_spectrum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Configure::set_has_spectrum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Configure::clear_has_spectrum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Configure::clear_spectrum() {
  if (spectrum_ != NULL) spectrum_->::KismetDatasource::SubSpecset::Clear();
  clear_has_spectrum();
}
inline const ::KismetDatasource::SubSpecset& Configure::spectrum() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.Configure.spectrum)
  return spectrum_ != NULL ? *spectrum_ : *default_instance_->spectrum_;
}
inline ::KismetDatasource::SubSpecset* Configure::mutable_spectrum() {
  set_has_spectrum();
  if (spectrum_ == NULL) {
    spectrum_ = new ::KismetDatasource::SubSpecset;
  }
  // @@protoc_insertion_point(field_mutable:KismetDatasource.Configure.spectrum)
  return spectrum_;
}
inline ::KismetDatasource::SubSpecset* Configure::release_spectrum() {
  // @@protoc_insertion_point(field_release:KismetDatasource.Configure.spectrum)
  clear_has_spectrum();
  ::KismetDatasource::SubSpecset* temp = spectrum_;
  spectrum_ = NULL;
  return temp;
}
inline void Configure::set_allocated_spectrum(::KismetDatasource::SubSpecset* spectrum) {
  delete spectrum_;
  spectrum_ = spectrum;
  if (spectrum) {
    set_has_spectrum();
  } else {
    clear_has_spectrum();
  }
  // @@protoc_insertion_point(field_set_allocated:KismetDatasource.Configure.spectrum)
}

// -------------------------------------------------------------------

// ConfigureReport

// required .KismetDatasource.SubSuccess success = 1;
inline bool ConfigureReport::has_success() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConfigureReport::set_has_success() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConfigureReport::clear_has_success() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConfigureReport::clear_success() {
  if (success_ != NULL) success_->::KismetDatasource::SubSuccess::Clear();
  clear_has_success();
}
inline const ::KismetDatasource::SubSuccess& ConfigureReport::success() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.ConfigureReport.success)
  return success_ != NULL ? *success_ : *default_instance_->success_;
}
inline ::KismetDatasource::SubSuccess* ConfigureReport::mutable_success() {
  set_has_success();
  if (success_ == NULL) {
    success_ = new ::KismetDatasource::SubSuccess;
  }
  // @@protoc_insertion_point(field_mutable:KismetDatasource.ConfigureReport.success)
  return success_;
}
inline ::KismetDatasource::SubSuccess* ConfigureReport::release_success() {
  // @@protoc_insertion_point(field_release:KismetDatasource.ConfigureReport.success)
  clear_has_success();
  ::KismetDatasource::SubSuccess* temp = success_;
  success_ = NULL;
  return temp;
}
inline void ConfigureReport::set_allocated_success(::KismetDatasource::SubSuccess* success) {
  delete success_;
  success_ = success;
  if (success) {
    set_has_success();
  } else {
    clear_has_success();
  }
  // @@protoc_insertion_point(field_set_allocated:KismetDatasource.ConfigureReport.success)
}

// optional .KismetDatasource.SubChanset channel = 2;
inline bool ConfigureReport::has_channel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConfigureReport::set_has_channel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConfigureReport::clear_has_channel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConfigureReport::clear_channel() {
  if (channel_ != NULL) channel_->::KismetDatasource::SubChanset::Clear();
  clear_has_channel();
}
inline const ::KismetDatasource::SubChanset& ConfigureReport::channel() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.ConfigureReport.channel)
  return channel_ != NULL ? *channel_ : *default_instance_->channel_;
}
inline ::KismetDatasource::SubChanset* ConfigureReport::mutable_channel() {
  set_has_channel();
  if (channel_ == NULL) {
    channel_ = new ::KismetDatasource::SubChanset;
  }
  // @@protoc_insertion_point(field_mutable:KismetDatasource.ConfigureReport.channel)
  return channel_;
}
inline ::KismetDatasource::SubChanset* ConfigureReport::release_channel() {
  // @@protoc_insertion_point(field_release:KismetDatasource.ConfigureReport.channel)
  clear_has_channel();
  ::KismetDatasource::SubChanset* temp = channel_;
  channel_ = NULL;
  return temp;
}
inline void ConfigureReport::set_allocated_channel(::KismetDatasource::SubChanset* channel) {
  delete channel_;
  channel_ = channel;
  if (channel) {
    set_has_channel();
  } else {
    clear_has_channel();
  }
  // @@protoc_insertion_point(field_set_allocated:KismetDatasource.ConfigureReport.channel)
}

// optional .KismetDatasource.SubChanhop hopping = 3;
inline bool ConfigureReport::has_hopping() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConfigureReport::set_has_hopping() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConfigureReport::clear_has_hopping() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConfigureReport::clear_hopping() {
  if (hopping_ != NULL) hopping_->::KismetDatasource::SubChanhop::Clear();
  clear_has_hopping();
}
inline const ::KismetDatasource::SubChanhop& ConfigureReport::hopping() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.ConfigureReport.hopping)
  return hopping_ != NULL ? *hopping_ : *default_instance_->hopping_;
}
inline ::KismetDatasource::SubChanhop* ConfigureReport::mutable_hopping() {
  set_has_hopping();
  if (hopping_ == NULL) {
    hopping_ = new ::KismetDatasource::SubChanhop;
  }
  // @@protoc_insertion_point(field_mutable:KismetDatasource.ConfigureReport.hopping)
  return hopping_;
}
inline ::KismetDatasource::SubChanhop* ConfigureReport::release_hopping() {
  // @@protoc_insertion_point(field_release:KismetDatasource.ConfigureReport.hopping)
  clear_has_hopping();
  ::KismetDatasource::SubChanhop* temp = hopping_;
  hopping_ = NULL;
  return temp;
}
inline void ConfigureReport::set_allocated_hopping(::KismetDatasource::SubChanhop* hopping) {
  delete hopping_;
  hopping_ = hopping;
  if (hopping) {
    set_has_hopping();
  } else {
    clear_has_hopping();
  }
  // @@protoc_insertion_point(field_set_allocated:KismetDatasource.ConfigureReport.hopping)
}

// optional .KismetDatasource.SubMsgbus message = 4;
inline bool ConfigureReport::has_message() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ConfigureReport::set_has_message() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ConfigureReport::clear_has_message() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ConfigureReport::clear_message() {
  if (message_ != NULL) message_->::KismetDatasource::SubMsgbus::Clear();
  clear_has_message();
}
inline const ::KismetDatasource::SubMsgbus& ConfigureReport::message() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.ConfigureReport.message)
  return message_ != NULL ? *message_ : *default_instance_->message_;
}
inline ::KismetDatasource::SubMsgbus* ConfigureReport::mutable_message() {
  set_has_message();
  if (message_ == NULL) {
    message_ = new ::KismetDatasource::SubMsgbus;
  }
  // @@protoc_insertion_point(field_mutable:KismetDatasource.ConfigureReport.message)
  return message_;
}
inline ::KismetDatasource::SubMsgbus* ConfigureReport::release_message() {
  // @@protoc_insertion_point(field_release:KismetDatasource.ConfigureReport.message)
  clear_has_message();
  ::KismetDatasource::SubMsgbus* temp = message_;
  message_ = NULL;
  return temp;
}
inline void ConfigureReport::set_allocated_message(::KismetDatasource::SubMsgbus* message) {
  delete message_;
  message_ = message;
  if (message) {
    set_has_message();
  } else {
    clear_has_message();
  }
  // @@protoc_insertion_point(field_set_allocated:KismetDatasource.ConfigureReport.message)
}

// optional string warning = 5;
inline bool ConfigureReport::has_warning() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ConfigureReport::set_has_warning() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ConfigureReport::clear_has_warning() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ConfigureReport::clear_warning() {
  warning_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_warning();
}
inline const ::std::string& ConfigureReport::warning() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.ConfigureReport.warning)
  return warning_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConfigureReport::set_warning(const ::std::string& value) {
  set_has_warning();
  warning_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:KismetDatasource.ConfigureReport.warning)
}
inline void ConfigureReport::set_warning(const char* value) {
  set_has_warning();
  warning_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:KismetDatasource.ConfigureReport.warning)
}
inline void ConfigureReport::set_warning(const char* value, size_t size) {
  set_has_warning();
  warning_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:KismetDatasource.ConfigureReport.warning)
}
inline ::std::string* ConfigureReport::mutable_warning() {
  set_has_warning();
  // @@protoc_insertion_point(field_mutable:KismetDatasource.ConfigureReport.warning)
  return warning_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConfigureReport::release_warning() {
  // @@protoc_insertion_point(field_release:KismetDatasource.ConfigureReport.warning)
  clear_has_warning();
  return warning_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConfigureReport::set_allocated_warning(::std::string* warning) {
  if (warning != NULL) {
    set_has_warning();
  } else {
    clear_has_warning();
  }
  warning_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), warning);
  // @@protoc_insertion_point(field_set_allocated:KismetDatasource.ConfigureReport.warning)
}

// -------------------------------------------------------------------

// DataReport

// optional .KismetDatasource.SubGps gps = 1;
inline bool DataReport::has_gps() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataReport::set_has_gps() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataReport::clear_has_gps() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DataReport::clear_gps() {
  if (gps_ != NULL) gps_->::KismetDatasource::SubGps::Clear();
  clear_has_gps();
}
inline const ::KismetDatasource::SubGps& DataReport::gps() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.DataReport.gps)
  return gps_ != NULL ? *gps_ : *default_instance_->gps_;
}
inline ::KismetDatasource::SubGps* DataReport::mutable_gps() {
  set_has_gps();
  if (gps_ == NULL) {
    gps_ = new ::KismetDatasource::SubGps;
  }
  // @@protoc_insertion_point(field_mutable:KismetDatasource.DataReport.gps)
  return gps_;
}
inline ::KismetDatasource::SubGps* DataReport::release_gps() {
  // @@protoc_insertion_point(field_release:KismetDatasource.DataReport.gps)
  clear_has_gps();
  ::KismetDatasource::SubGps* temp = gps_;
  gps_ = NULL;
  return temp;
}
inline void DataReport::set_allocated_gps(::KismetDatasource::SubGps* gps) {
  delete gps_;
  gps_ = gps;
  if (gps) {
    set_has_gps();
  } else {
    clear_has_gps();
  }
  // @@protoc_insertion_point(field_set_allocated:KismetDatasource.DataReport.gps)
}

// optional .KismetDatasource.SubMsgbus message = 2;
inline bool DataReport::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataReport::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataReport::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataReport::clear_message() {
  if (message_ != NULL) message_->::KismetDatasource::SubMsgbus::Clear();
  clear_has_message();
}
inline const ::KismetDatasource::SubMsgbus& DataReport::message() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.DataReport.message)
  return message_ != NULL ? *message_ : *default_instance_->message_;
}
inline ::KismetDatasource::SubMsgbus* DataReport::mutable_message() {
  set_has_message();
  if (message_ == NULL) {
    message_ = new ::KismetDatasource::SubMsgbus;
  }
  // @@protoc_insertion_point(field_mutable:KismetDatasource.DataReport.message)
  return message_;
}
inline ::KismetDatasource::SubMsgbus* DataReport::release_message() {
  // @@protoc_insertion_point(field_release:KismetDatasource.DataReport.message)
  clear_has_message();
  ::KismetDatasource::SubMsgbus* temp = message_;
  message_ = NULL;
  return temp;
}
inline void DataReport::set_allocated_message(::KismetDatasource::SubMsgbus* message) {
  delete message_;
  message_ = message;
  if (message) {
    set_has_message();
  } else {
    clear_has_message();
  }
  // @@protoc_insertion_point(field_set_allocated:KismetDatasource.DataReport.message)
}

// optional .KismetDatasource.SubPacket packet = 3;
inline bool DataReport::has_packet() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DataReport::set_has_packet() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DataReport::clear_has_packet() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DataReport::clear_packet() {
  if (packet_ != NULL) packet_->::KismetDatasource::SubPacket::Clear();
  clear_has_packet();
}
inline const ::KismetDatasource::SubPacket& DataReport::packet() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.DataReport.packet)
  return packet_ != NULL ? *packet_ : *default_instance_->packet_;
}
inline ::KismetDatasource::SubPacket* DataReport::mutable_packet() {
  set_has_packet();
  if (packet_ == NULL) {
    packet_ = new ::KismetDatasource::SubPacket;
  }
  // @@protoc_insertion_point(field_mutable:KismetDatasource.DataReport.packet)
  return packet_;
}
inline ::KismetDatasource::SubPacket* DataReport::release_packet() {
  // @@protoc_insertion_point(field_release:KismetDatasource.DataReport.packet)
  clear_has_packet();
  ::KismetDatasource::SubPacket* temp = packet_;
  packet_ = NULL;
  return temp;
}
inline void DataReport::set_allocated_packet(::KismetDatasource::SubPacket* packet) {
  delete packet_;
  packet_ = packet;
  if (packet) {
    set_has_packet();
  } else {
    clear_has_packet();
  }
  // @@protoc_insertion_point(field_set_allocated:KismetDatasource.DataReport.packet)
}

// optional .KismetDatasource.SubSignal signal = 4;
inline bool DataReport::has_signal() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DataReport::set_has_signal() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DataReport::clear_has_signal() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DataReport::clear_signal() {
  if (signal_ != NULL) signal_->::KismetDatasource::SubSignal::Clear();
  clear_has_signal();
}
inline const ::KismetDatasource::SubSignal& DataReport::signal() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.DataReport.signal)
  return signal_ != NULL ? *signal_ : *default_instance_->signal_;
}
inline ::KismetDatasource::SubSignal* DataReport::mutable_signal() {
  set_has_signal();
  if (signal_ == NULL) {
    signal_ = new ::KismetDatasource::SubSignal;
  }
  // @@protoc_insertion_point(field_mutable:KismetDatasource.DataReport.signal)
  return signal_;
}
inline ::KismetDatasource::SubSignal* DataReport::release_signal() {
  // @@protoc_insertion_point(field_release:KismetDatasource.DataReport.signal)
  clear_has_signal();
  ::KismetDatasource::SubSignal* temp = signal_;
  signal_ = NULL;
  return temp;
}
inline void DataReport::set_allocated_signal(::KismetDatasource::SubSignal* signal) {
  delete signal_;
  signal_ = signal;
  if (signal) {
    set_has_signal();
  } else {
    clear_has_signal();
  }
  // @@protoc_insertion_point(field_set_allocated:KismetDatasource.DataReport.signal)
}

// optional .KismetDatasource.SubSpectrum spectrum = 5;
inline bool DataReport::has_spectrum() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DataReport::set_has_spectrum() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DataReport::clear_has_spectrum() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DataReport::clear_spectrum() {
  if (spectrum_ != NULL) spectrum_->::KismetDatasource::SubSpectrum::Clear();
  clear_has_spectrum();
}
inline const ::KismetDatasource::SubSpectrum& DataReport::spectrum() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.DataReport.spectrum)
  return spectrum_ != NULL ? *spectrum_ : *default_instance_->spectrum_;
}
inline ::KismetDatasource::SubSpectrum* DataReport::mutable_spectrum() {
  set_has_spectrum();
  if (spectrum_ == NULL) {
    spectrum_ = new ::KismetDatasource::SubSpectrum;
  }
  // @@protoc_insertion_point(field_mutable:KismetDatasource.DataReport.spectrum)
  return spectrum_;
}
inline ::KismetDatasource::SubSpectrum* DataReport::release_spectrum() {
  // @@protoc_insertion_point(field_release:KismetDatasource.DataReport.spectrum)
  clear_has_spectrum();
  ::KismetDatasource::SubSpectrum* temp = spectrum_;
  spectrum_ = NULL;
  return temp;
}
inline void DataReport::set_allocated_spectrum(::KismetDatasource::SubSpectrum* spectrum) {
  delete spectrum_;
  spectrum_ = spectrum;
  if (spectrum) {
    set_has_spectrum();
  } else {
    clear_has_spectrum();
  }
  // @@protoc_insertion_point(field_set_allocated:KismetDatasource.DataReport.spectrum)
}

// optional string warning = 6;
inline bool DataReport::has_warning() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DataReport::set_has_warning() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DataReport::clear_has_warning() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DataReport::clear_warning() {
  warning_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_warning();
}
inline const ::std::string& DataReport::warning() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.DataReport.warning)
  return warning_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DataReport::set_warning(const ::std::string& value) {
  set_has_warning();
  warning_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:KismetDatasource.DataReport.warning)
}
inline void DataReport::set_warning(const char* value) {
  set_has_warning();
  warning_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:KismetDatasource.DataReport.warning)
}
inline void DataReport::set_warning(const char* value, size_t size) {
  set_has_warning();
  warning_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:KismetDatasource.DataReport.warning)
}
inline ::std::string* DataReport::mutable_warning() {
  set_has_warning();
  // @@protoc_insertion_point(field_mutable:KismetDatasource.DataReport.warning)
  return warning_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DataReport::release_warning() {
  // @@protoc_insertion_point(field_release:KismetDatasource.DataReport.warning)
  clear_has_warning();
  return warning_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DataReport::set_allocated_warning(::std::string* warning) {
  if (warning != NULL) {
    set_has_warning();
  } else {
    clear_has_warning();
  }
  warning_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), warning);
  // @@protoc_insertion_point(field_set_allocated:KismetDatasource.DataReport.warning)
}

// -------------------------------------------------------------------

// ErrorReport

// required .KismetDatasource.SubSuccess success = 1;
inline bool ErrorReport::has_success() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ErrorReport::set_has_success() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ErrorReport::clear_has_success() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ErrorReport::clear_success() {
  if (success_ != NULL) success_->::KismetDatasource::SubSuccess::Clear();
  clear_has_success();
}
inline const ::KismetDatasource::SubSuccess& ErrorReport::success() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.ErrorReport.success)
  return success_ != NULL ? *success_ : *default_instance_->success_;
}
inline ::KismetDatasource::SubSuccess* ErrorReport::mutable_success() {
  set_has_success();
  if (success_ == NULL) {
    success_ = new ::KismetDatasource::SubSuccess;
  }
  // @@protoc_insertion_point(field_mutable:KismetDatasource.ErrorReport.success)
  return success_;
}
inline ::KismetDatasource::SubSuccess* ErrorReport::release_success() {
  // @@protoc_insertion_point(field_release:KismetDatasource.ErrorReport.success)
  clear_has_success();
  ::KismetDatasource::SubSuccess* temp = success_;
  success_ = NULL;
  return temp;
}
inline void ErrorReport::set_allocated_success(::KismetDatasource::SubSuccess* success) {
  delete success_;
  success_ = success;
  if (success) {
    set_has_success();
  } else {
    clear_has_success();
  }
  // @@protoc_insertion_point(field_set_allocated:KismetDatasource.ErrorReport.success)
}

// optional .KismetDatasource.SubMsgbus message = 2;
inline bool ErrorReport::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ErrorReport::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ErrorReport::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ErrorReport::clear_message() {
  if (message_ != NULL) message_->::KismetDatasource::SubMsgbus::Clear();
  clear_has_message();
}
inline const ::KismetDatasource::SubMsgbus& ErrorReport::message() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.ErrorReport.message)
  return message_ != NULL ? *message_ : *default_instance_->message_;
}
inline ::KismetDatasource::SubMsgbus* ErrorReport::mutable_message() {
  set_has_message();
  if (message_ == NULL) {
    message_ = new ::KismetDatasource::SubMsgbus;
  }
  // @@protoc_insertion_point(field_mutable:KismetDatasource.ErrorReport.message)
  return message_;
}
inline ::KismetDatasource::SubMsgbus* ErrorReport::release_message() {
  // @@protoc_insertion_point(field_release:KismetDatasource.ErrorReport.message)
  clear_has_message();
  ::KismetDatasource::SubMsgbus* temp = message_;
  message_ = NULL;
  return temp;
}
inline void ErrorReport::set_allocated_message(::KismetDatasource::SubMsgbus* message) {
  delete message_;
  message_ = message;
  if (message) {
    set_has_message();
  } else {
    clear_has_message();
  }
  // @@protoc_insertion_point(field_set_allocated:KismetDatasource.ErrorReport.message)
}

// -------------------------------------------------------------------

// ListInterfaces

// -------------------------------------------------------------------

// InterfacesReport

// required .KismetDatasource.SubSuccess success = 1;
inline bool InterfacesReport::has_success() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InterfacesReport::set_has_success() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InterfacesReport::clear_has_success() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InterfacesReport::clear_success() {
  if (success_ != NULL) success_->::KismetDatasource::SubSuccess::Clear();
  clear_has_success();
}
inline const ::KismetDatasource::SubSuccess& InterfacesReport::success() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.InterfacesReport.success)
  return success_ != NULL ? *success_ : *default_instance_->success_;
}
inline ::KismetDatasource::SubSuccess* InterfacesReport::mutable_success() {
  set_has_success();
  if (success_ == NULL) {
    success_ = new ::KismetDatasource::SubSuccess;
  }
  // @@protoc_insertion_point(field_mutable:KismetDatasource.InterfacesReport.success)
  return success_;
}
inline ::KismetDatasource::SubSuccess* InterfacesReport::release_success() {
  // @@protoc_insertion_point(field_release:KismetDatasource.InterfacesReport.success)
  clear_has_success();
  ::KismetDatasource::SubSuccess* temp = success_;
  success_ = NULL;
  return temp;
}
inline void InterfacesReport::set_allocated_success(::KismetDatasource::SubSuccess* success) {
  delete success_;
  success_ = success;
  if (success) {
    set_has_success();
  } else {
    clear_has_success();
  }
  // @@protoc_insertion_point(field_set_allocated:KismetDatasource.InterfacesReport.success)
}

// optional .KismetDatasource.SubMsgbus message = 2;
inline bool InterfacesReport::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InterfacesReport::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InterfacesReport::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InterfacesReport::clear_message() {
  if (message_ != NULL) message_->::KismetDatasource::SubMsgbus::Clear();
  clear_has_message();
}
inline const ::KismetDatasource::SubMsgbus& InterfacesReport::message() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.InterfacesReport.message)
  return message_ != NULL ? *message_ : *default_instance_->message_;
}
inline ::KismetDatasource::SubMsgbus* InterfacesReport::mutable_message() {
  set_has_message();
  if (message_ == NULL) {
    message_ = new ::KismetDatasource::SubMsgbus;
  }
  // @@protoc_insertion_point(field_mutable:KismetDatasource.InterfacesReport.message)
  return message_;
}
inline ::KismetDatasource::SubMsgbus* InterfacesReport::release_message() {
  // @@protoc_insertion_point(field_release:KismetDatasource.InterfacesReport.message)
  clear_has_message();
  ::KismetDatasource::SubMsgbus* temp = message_;
  message_ = NULL;
  return temp;
}
inline void InterfacesReport::set_allocated_message(::KismetDatasource::SubMsgbus* message) {
  delete message_;
  message_ = message;
  if (message) {
    set_has_message();
  } else {
    clear_has_message();
  }
  // @@protoc_insertion_point(field_set_allocated:KismetDatasource.InterfacesReport.message)
}

// repeated .KismetDatasource.SubInterface interfaces = 3;
inline int InterfacesReport::interfaces_size() const {
  return interfaces_.size();
}
inline void InterfacesReport::clear_interfaces() {
  interfaces_.Clear();
}
inline const ::KismetDatasource::SubInterface& InterfacesReport::interfaces(int index) const {
  // @@protoc_insertion_point(field_get:KismetDatasource.InterfacesReport.interfaces)
  return interfaces_.Get(index);
}
inline ::KismetDatasource::SubInterface* InterfacesReport::mutable_interfaces(int index) {
  // @@protoc_insertion_point(field_mutable:KismetDatasource.InterfacesReport.interfaces)
  return interfaces_.Mutable(index);
}
inline ::KismetDatasource::SubInterface* InterfacesReport::add_interfaces() {
  // @@protoc_insertion_point(field_add:KismetDatasource.InterfacesReport.interfaces)
  return interfaces_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::KismetDatasource::SubInterface >*
InterfacesReport::mutable_interfaces() {
  // @@protoc_insertion_point(field_mutable_list:KismetDatasource.InterfacesReport.interfaces)
  return &interfaces_;
}
inline const ::google::protobuf::RepeatedPtrField< ::KismetDatasource::SubInterface >&
InterfacesReport::interfaces() const {
  // @@protoc_insertion_point(field_list:KismetDatasource.InterfacesReport.interfaces)
  return interfaces_;
}

// -------------------------------------------------------------------

// Message

// optional .KismetDatasource.SubMsgbus message = 1;
inline bool Message::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message::clear_message() {
  if (message_ != NULL) message_->::KismetDatasource::SubMsgbus::Clear();
  clear_has_message();
}
inline const ::KismetDatasource::SubMsgbus& Message::message() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.Message.message)
  return message_ != NULL ? *message_ : *default_instance_->message_;
}
inline ::KismetDatasource::SubMsgbus* Message::mutable_message() {
  set_has_message();
  if (message_ == NULL) {
    message_ = new ::KismetDatasource::SubMsgbus;
  }
  // @@protoc_insertion_point(field_mutable:KismetDatasource.Message.message)
  return message_;
}
inline ::KismetDatasource::SubMsgbus* Message::release_message() {
  // @@protoc_insertion_point(field_release:KismetDatasource.Message.message)
  clear_has_message();
  ::KismetDatasource::SubMsgbus* temp = message_;
  message_ = NULL;
  return temp;
}
inline void Message::set_allocated_message(::KismetDatasource::SubMsgbus* message) {
  delete message_;
  message_ = message;
  if (message) {
    set_has_message();
  } else {
    clear_has_message();
  }
  // @@protoc_insertion_point(field_set_allocated:KismetDatasource.Message.message)
}

// optional string warning = 2;
inline bool Message::has_warning() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message::set_has_warning() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Message::clear_has_warning() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Message::clear_warning() {
  warning_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_warning();
}
inline const ::std::string& Message::warning() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.Message.warning)
  return warning_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Message::set_warning(const ::std::string& value) {
  set_has_warning();
  warning_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:KismetDatasource.Message.warning)
}
inline void Message::set_warning(const char* value) {
  set_has_warning();
  warning_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:KismetDatasource.Message.warning)
}
inline void Message::set_warning(const char* value, size_t size) {
  set_has_warning();
  warning_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:KismetDatasource.Message.warning)
}
inline ::std::string* Message::mutable_warning() {
  set_has_warning();
  // @@protoc_insertion_point(field_mutable:KismetDatasource.Message.warning)
  return warning_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Message::release_warning() {
  // @@protoc_insertion_point(field_release:KismetDatasource.Message.warning)
  clear_has_warning();
  return warning_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Message::set_allocated_warning(::std::string* warning) {
  if (warning != NULL) {
    set_has_warning();
  } else {
    clear_has_warning();
  }
  warning_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), warning);
  // @@protoc_insertion_point(field_set_allocated:KismetDatasource.Message.warning)
}

// -------------------------------------------------------------------

// NewSource

// required string definition = 1;
inline bool NewSource::has_definition() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewSource::set_has_definition() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewSource::clear_has_definition() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewSource::clear_definition() {
  definition_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_definition();
}
inline const ::std::string& NewSource::definition() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.NewSource.definition)
  return definition_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewSource::set_definition(const ::std::string& value) {
  set_has_definition();
  definition_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:KismetDatasource.NewSource.definition)
}
inline void NewSource::set_definition(const char* value) {
  set_has_definition();
  definition_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:KismetDatasource.NewSource.definition)
}
inline void NewSource::set_definition(const char* value, size_t size) {
  set_has_definition();
  definition_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:KismetDatasource.NewSource.definition)
}
inline ::std::string* NewSource::mutable_definition() {
  set_has_definition();
  // @@protoc_insertion_point(field_mutable:KismetDatasource.NewSource.definition)
  return definition_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewSource::release_definition() {
  // @@protoc_insertion_point(field_release:KismetDatasource.NewSource.definition)
  clear_has_definition();
  return definition_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewSource::set_allocated_definition(::std::string* definition) {
  if (definition != NULL) {
    set_has_definition();
  } else {
    clear_has_definition();
  }
  definition_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), definition);
  // @@protoc_insertion_point(field_set_allocated:KismetDatasource.NewSource.definition)
}

// required string sourcetype = 2;
inline bool NewSource::has_sourcetype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NewSource::set_has_sourcetype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NewSource::clear_has_sourcetype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NewSource::clear_sourcetype() {
  sourcetype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sourcetype();
}
inline const ::std::string& NewSource::sourcetype() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.NewSource.sourcetype)
  return sourcetype_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewSource::set_sourcetype(const ::std::string& value) {
  set_has_sourcetype();
  sourcetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:KismetDatasource.NewSource.sourcetype)
}
inline void NewSource::set_sourcetype(const char* value) {
  set_has_sourcetype();
  sourcetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:KismetDatasource.NewSource.sourcetype)
}
inline void NewSource::set_sourcetype(const char* value, size_t size) {
  set_has_sourcetype();
  sourcetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:KismetDatasource.NewSource.sourcetype)
}
inline ::std::string* NewSource::mutable_sourcetype() {
  set_has_sourcetype();
  // @@protoc_insertion_point(field_mutable:KismetDatasource.NewSource.sourcetype)
  return sourcetype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewSource::release_sourcetype() {
  // @@protoc_insertion_point(field_release:KismetDatasource.NewSource.sourcetype)
  clear_has_sourcetype();
  return sourcetype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewSource::set_allocated_sourcetype(::std::string* sourcetype) {
  if (sourcetype != NULL) {
    set_has_sourcetype();
  } else {
    clear_has_sourcetype();
  }
  sourcetype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sourcetype);
  // @@protoc_insertion_point(field_set_allocated:KismetDatasource.NewSource.sourcetype)
}

// required string uuid = 3;
inline bool NewSource::has_uuid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NewSource::set_has_uuid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NewSource::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NewSource::clear_uuid() {
  uuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_uuid();
}
inline const ::std::string& NewSource::uuid() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.NewSource.uuid)
  return uuid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewSource::set_uuid(const ::std::string& value) {
  set_has_uuid();
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:KismetDatasource.NewSource.uuid)
}
inline void NewSource::set_uuid(const char* value) {
  set_has_uuid();
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:KismetDatasource.NewSource.uuid)
}
inline void NewSource::set_uuid(const char* value, size_t size) {
  set_has_uuid();
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:KismetDatasource.NewSource.uuid)
}
inline ::std::string* NewSource::mutable_uuid() {
  set_has_uuid();
  // @@protoc_insertion_point(field_mutable:KismetDatasource.NewSource.uuid)
  return uuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewSource::release_uuid() {
  // @@protoc_insertion_point(field_release:KismetDatasource.NewSource.uuid)
  clear_has_uuid();
  return uuid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewSource::set_allocated_uuid(::std::string* uuid) {
  if (uuid != NULL) {
    set_has_uuid();
  } else {
    clear_has_uuid();
  }
  uuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uuid);
  // @@protoc_insertion_point(field_set_allocated:KismetDatasource.NewSource.uuid)
}

// -------------------------------------------------------------------

// OpenSource

// required string definition = 1;
inline bool OpenSource::has_definition() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OpenSource::set_has_definition() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OpenSource::clear_has_definition() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OpenSource::clear_definition() {
  definition_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_definition();
}
inline const ::std::string& OpenSource::definition() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.OpenSource.definition)
  return definition_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OpenSource::set_definition(const ::std::string& value) {
  set_has_definition();
  definition_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:KismetDatasource.OpenSource.definition)
}
inline void OpenSource::set_definition(const char* value) {
  set_has_definition();
  definition_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:KismetDatasource.OpenSource.definition)
}
inline void OpenSource::set_definition(const char* value, size_t size) {
  set_has_definition();
  definition_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:KismetDatasource.OpenSource.definition)
}
inline ::std::string* OpenSource::mutable_definition() {
  set_has_definition();
  // @@protoc_insertion_point(field_mutable:KismetDatasource.OpenSource.definition)
  return definition_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OpenSource::release_definition() {
  // @@protoc_insertion_point(field_release:KismetDatasource.OpenSource.definition)
  clear_has_definition();
  return definition_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OpenSource::set_allocated_definition(::std::string* definition) {
  if (definition != NULL) {
    set_has_definition();
  } else {
    clear_has_definition();
  }
  definition_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), definition);
  // @@protoc_insertion_point(field_set_allocated:KismetDatasource.OpenSource.definition)
}

// -------------------------------------------------------------------

// OpenSourceReport

// required .KismetDatasource.SubSuccess success = 1;
inline bool OpenSourceReport::has_success() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OpenSourceReport::set_has_success() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OpenSourceReport::clear_has_success() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OpenSourceReport::clear_success() {
  if (success_ != NULL) success_->::KismetDatasource::SubSuccess::Clear();
  clear_has_success();
}
inline const ::KismetDatasource::SubSuccess& OpenSourceReport::success() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.OpenSourceReport.success)
  return success_ != NULL ? *success_ : *default_instance_->success_;
}
inline ::KismetDatasource::SubSuccess* OpenSourceReport::mutable_success() {
  set_has_success();
  if (success_ == NULL) {
    success_ = new ::KismetDatasource::SubSuccess;
  }
  // @@protoc_insertion_point(field_mutable:KismetDatasource.OpenSourceReport.success)
  return success_;
}
inline ::KismetDatasource::SubSuccess* OpenSourceReport::release_success() {
  // @@protoc_insertion_point(field_release:KismetDatasource.OpenSourceReport.success)
  clear_has_success();
  ::KismetDatasource::SubSuccess* temp = success_;
  success_ = NULL;
  return temp;
}
inline void OpenSourceReport::set_allocated_success(::KismetDatasource::SubSuccess* success) {
  delete success_;
  success_ = success;
  if (success) {
    set_has_success();
  } else {
    clear_has_success();
  }
  // @@protoc_insertion_point(field_set_allocated:KismetDatasource.OpenSourceReport.success)
}

// optional uint32 dlt = 2;
inline bool OpenSourceReport::has_dlt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OpenSourceReport::set_has_dlt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OpenSourceReport::clear_has_dlt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OpenSourceReport::clear_dlt() {
  dlt_ = 0u;
  clear_has_dlt();
}
inline ::google::protobuf::uint32 OpenSourceReport::dlt() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.OpenSourceReport.dlt)
  return dlt_;
}
inline void OpenSourceReport::set_dlt(::google::protobuf::uint32 value) {
  set_has_dlt();
  dlt_ = value;
  // @@protoc_insertion_point(field_set:KismetDatasource.OpenSourceReport.dlt)
}

// optional string capture_interface = 3;
inline bool OpenSourceReport::has_capture_interface() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OpenSourceReport::set_has_capture_interface() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OpenSourceReport::clear_has_capture_interface() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OpenSourceReport::clear_capture_interface() {
  capture_interface_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_capture_interface();
}
inline const ::std::string& OpenSourceReport::capture_interface() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.OpenSourceReport.capture_interface)
  return capture_interface_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OpenSourceReport::set_capture_interface(const ::std::string& value) {
  set_has_capture_interface();
  capture_interface_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:KismetDatasource.OpenSourceReport.capture_interface)
}
inline void OpenSourceReport::set_capture_interface(const char* value) {
  set_has_capture_interface();
  capture_interface_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:KismetDatasource.OpenSourceReport.capture_interface)
}
inline void OpenSourceReport::set_capture_interface(const char* value, size_t size) {
  set_has_capture_interface();
  capture_interface_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:KismetDatasource.OpenSourceReport.capture_interface)
}
inline ::std::string* OpenSourceReport::mutable_capture_interface() {
  set_has_capture_interface();
  // @@protoc_insertion_point(field_mutable:KismetDatasource.OpenSourceReport.capture_interface)
  return capture_interface_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OpenSourceReport::release_capture_interface() {
  // @@protoc_insertion_point(field_release:KismetDatasource.OpenSourceReport.capture_interface)
  clear_has_capture_interface();
  return capture_interface_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OpenSourceReport::set_allocated_capture_interface(::std::string* capture_interface) {
  if (capture_interface != NULL) {
    set_has_capture_interface();
  } else {
    clear_has_capture_interface();
  }
  capture_interface_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), capture_interface);
  // @@protoc_insertion_point(field_set_allocated:KismetDatasource.OpenSourceReport.capture_interface)
}

// optional .KismetDatasource.SubChannels channels = 4;
inline bool OpenSourceReport::has_channels() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OpenSourceReport::set_has_channels() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OpenSourceReport::clear_has_channels() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OpenSourceReport::clear_channels() {
  if (channels_ != NULL) channels_->::KismetDatasource::SubChannels::Clear();
  clear_has_channels();
}
inline const ::KismetDatasource::SubChannels& OpenSourceReport::channels() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.OpenSourceReport.channels)
  return channels_ != NULL ? *channels_ : *default_instance_->channels_;
}
inline ::KismetDatasource::SubChannels* OpenSourceReport::mutable_channels() {
  set_has_channels();
  if (channels_ == NULL) {
    channels_ = new ::KismetDatasource::SubChannels;
  }
  // @@protoc_insertion_point(field_mutable:KismetDatasource.OpenSourceReport.channels)
  return channels_;
}
inline ::KismetDatasource::SubChannels* OpenSourceReport::release_channels() {
  // @@protoc_insertion_point(field_release:KismetDatasource.OpenSourceReport.channels)
  clear_has_channels();
  ::KismetDatasource::SubChannels* temp = channels_;
  channels_ = NULL;
  return temp;
}
inline void OpenSourceReport::set_allocated_channels(::KismetDatasource::SubChannels* channels) {
  delete channels_;
  channels_ = channels;
  if (channels) {
    set_has_channels();
  } else {
    clear_has_channels();
  }
  // @@protoc_insertion_point(field_set_allocated:KismetDatasource.OpenSourceReport.channels)
}

// optional .KismetDatasource.SubChanset channel = 5;
inline bool OpenSourceReport::has_channel() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OpenSourceReport::set_has_channel() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OpenSourceReport::clear_has_channel() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OpenSourceReport::clear_channel() {
  if (channel_ != NULL) channel_->::KismetDatasource::SubChanset::Clear();
  clear_has_channel();
}
inline const ::KismetDatasource::SubChanset& OpenSourceReport::channel() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.OpenSourceReport.channel)
  return channel_ != NULL ? *channel_ : *default_instance_->channel_;
}
inline ::KismetDatasource::SubChanset* OpenSourceReport::mutable_channel() {
  set_has_channel();
  if (channel_ == NULL) {
    channel_ = new ::KismetDatasource::SubChanset;
  }
  // @@protoc_insertion_point(field_mutable:KismetDatasource.OpenSourceReport.channel)
  return channel_;
}
inline ::KismetDatasource::SubChanset* OpenSourceReport::release_channel() {
  // @@protoc_insertion_point(field_release:KismetDatasource.OpenSourceReport.channel)
  clear_has_channel();
  ::KismetDatasource::SubChanset* temp = channel_;
  channel_ = NULL;
  return temp;
}
inline void OpenSourceReport::set_allocated_channel(::KismetDatasource::SubChanset* channel) {
  delete channel_;
  channel_ = channel;
  if (channel) {
    set_has_channel();
  } else {
    clear_has_channel();
  }
  // @@protoc_insertion_point(field_set_allocated:KismetDatasource.OpenSourceReport.channel)
}

// optional string hardware = 6;
inline bool OpenSourceReport::has_hardware() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OpenSourceReport::set_has_hardware() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OpenSourceReport::clear_has_hardware() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OpenSourceReport::clear_hardware() {
  hardware_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hardware();
}
inline const ::std::string& OpenSourceReport::hardware() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.OpenSourceReport.hardware)
  return hardware_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OpenSourceReport::set_hardware(const ::std::string& value) {
  set_has_hardware();
  hardware_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:KismetDatasource.OpenSourceReport.hardware)
}
inline void OpenSourceReport::set_hardware(const char* value) {
  set_has_hardware();
  hardware_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:KismetDatasource.OpenSourceReport.hardware)
}
inline void OpenSourceReport::set_hardware(const char* value, size_t size) {
  set_has_hardware();
  hardware_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:KismetDatasource.OpenSourceReport.hardware)
}
inline ::std::string* OpenSourceReport::mutable_hardware() {
  set_has_hardware();
  // @@protoc_insertion_point(field_mutable:KismetDatasource.OpenSourceReport.hardware)
  return hardware_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OpenSourceReport::release_hardware() {
  // @@protoc_insertion_point(field_release:KismetDatasource.OpenSourceReport.hardware)
  clear_has_hardware();
  return hardware_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OpenSourceReport::set_allocated_hardware(::std::string* hardware) {
  if (hardware != NULL) {
    set_has_hardware();
  } else {
    clear_has_hardware();
  }
  hardware_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hardware);
  // @@protoc_insertion_point(field_set_allocated:KismetDatasource.OpenSourceReport.hardware)
}

// optional .KismetDatasource.SubMsgbus message = 7;
inline bool OpenSourceReport::has_message() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void OpenSourceReport::set_has_message() {
  _has_bits_[0] |= 0x00000040u;
}
inline void OpenSourceReport::clear_has_message() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void OpenSourceReport::clear_message() {
  if (message_ != NULL) message_->::KismetDatasource::SubMsgbus::Clear();
  clear_has_message();
}
inline const ::KismetDatasource::SubMsgbus& OpenSourceReport::message() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.OpenSourceReport.message)
  return message_ != NULL ? *message_ : *default_instance_->message_;
}
inline ::KismetDatasource::SubMsgbus* OpenSourceReport::mutable_message() {
  set_has_message();
  if (message_ == NULL) {
    message_ = new ::KismetDatasource::SubMsgbus;
  }
  // @@protoc_insertion_point(field_mutable:KismetDatasource.OpenSourceReport.message)
  return message_;
}
inline ::KismetDatasource::SubMsgbus* OpenSourceReport::release_message() {
  // @@protoc_insertion_point(field_release:KismetDatasource.OpenSourceReport.message)
  clear_has_message();
  ::KismetDatasource::SubMsgbus* temp = message_;
  message_ = NULL;
  return temp;
}
inline void OpenSourceReport::set_allocated_message(::KismetDatasource::SubMsgbus* message) {
  delete message_;
  message_ = message;
  if (message) {
    set_has_message();
  } else {
    clear_has_message();
  }
  // @@protoc_insertion_point(field_set_allocated:KismetDatasource.OpenSourceReport.message)
}

// optional .KismetDatasource.SubSpecset specset = 8;
inline bool OpenSourceReport::has_specset() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void OpenSourceReport::set_has_specset() {
  _has_bits_[0] |= 0x00000080u;
}
inline void OpenSourceReport::clear_has_specset() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void OpenSourceReport::clear_specset() {
  if (specset_ != NULL) specset_->::KismetDatasource::SubSpecset::Clear();
  clear_has_specset();
}
inline const ::KismetDatasource::SubSpecset& OpenSourceReport::specset() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.OpenSourceReport.specset)
  return specset_ != NULL ? *specset_ : *default_instance_->specset_;
}
inline ::KismetDatasource::SubSpecset* OpenSourceReport::mutable_specset() {
  set_has_specset();
  if (specset_ == NULL) {
    specset_ = new ::KismetDatasource::SubSpecset;
  }
  // @@protoc_insertion_point(field_mutable:KismetDatasource.OpenSourceReport.specset)
  return specset_;
}
inline ::KismetDatasource::SubSpecset* OpenSourceReport::release_specset() {
  // @@protoc_insertion_point(field_release:KismetDatasource.OpenSourceReport.specset)
  clear_has_specset();
  ::KismetDatasource::SubSpecset* temp = specset_;
  specset_ = NULL;
  return temp;
}
inline void OpenSourceReport::set_allocated_specset(::KismetDatasource::SubSpecset* specset) {
  delete specset_;
  specset_ = specset;
  if (specset) {
    set_has_specset();
  } else {
    clear_has_specset();
  }
  // @@protoc_insertion_point(field_set_allocated:KismetDatasource.OpenSourceReport.specset)
}

// optional string uuid = 9;
inline bool OpenSourceReport::has_uuid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void OpenSourceReport::set_has_uuid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void OpenSourceReport::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void OpenSourceReport::clear_uuid() {
  uuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_uuid();
}
inline const ::std::string& OpenSourceReport::uuid() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.OpenSourceReport.uuid)
  return uuid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OpenSourceReport::set_uuid(const ::std::string& value) {
  set_has_uuid();
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:KismetDatasource.OpenSourceReport.uuid)
}
inline void OpenSourceReport::set_uuid(const char* value) {
  set_has_uuid();
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:KismetDatasource.OpenSourceReport.uuid)
}
inline void OpenSourceReport::set_uuid(const char* value, size_t size) {
  set_has_uuid();
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:KismetDatasource.OpenSourceReport.uuid)
}
inline ::std::string* OpenSourceReport::mutable_uuid() {
  set_has_uuid();
  // @@protoc_insertion_point(field_mutable:KismetDatasource.OpenSourceReport.uuid)
  return uuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OpenSourceReport::release_uuid() {
  // @@protoc_insertion_point(field_release:KismetDatasource.OpenSourceReport.uuid)
  clear_has_uuid();
  return uuid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OpenSourceReport::set_allocated_uuid(::std::string* uuid) {
  if (uuid != NULL) {
    set_has_uuid();
  } else {
    clear_has_uuid();
  }
  uuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uuid);
  // @@protoc_insertion_point(field_set_allocated:KismetDatasource.OpenSourceReport.uuid)
}

// optional string warning = 10;
inline bool OpenSourceReport::has_warning() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void OpenSourceReport::set_has_warning() {
  _has_bits_[0] |= 0x00000200u;
}
inline void OpenSourceReport::clear_has_warning() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void OpenSourceReport::clear_warning() {
  warning_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_warning();
}
inline const ::std::string& OpenSourceReport::warning() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.OpenSourceReport.warning)
  return warning_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OpenSourceReport::set_warning(const ::std::string& value) {
  set_has_warning();
  warning_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:KismetDatasource.OpenSourceReport.warning)
}
inline void OpenSourceReport::set_warning(const char* value) {
  set_has_warning();
  warning_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:KismetDatasource.OpenSourceReport.warning)
}
inline void OpenSourceReport::set_warning(const char* value, size_t size) {
  set_has_warning();
  warning_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:KismetDatasource.OpenSourceReport.warning)
}
inline ::std::string* OpenSourceReport::mutable_warning() {
  set_has_warning();
  // @@protoc_insertion_point(field_mutable:KismetDatasource.OpenSourceReport.warning)
  return warning_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OpenSourceReport::release_warning() {
  // @@protoc_insertion_point(field_release:KismetDatasource.OpenSourceReport.warning)
  clear_has_warning();
  return warning_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OpenSourceReport::set_allocated_warning(::std::string* warning) {
  if (warning != NULL) {
    set_has_warning();
  } else {
    clear_has_warning();
  }
  warning_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), warning);
  // @@protoc_insertion_point(field_set_allocated:KismetDatasource.OpenSourceReport.warning)
}

// -------------------------------------------------------------------

// ProbeSource

// required string definition = 1;
inline bool ProbeSource::has_definition() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProbeSource::set_has_definition() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProbeSource::clear_has_definition() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProbeSource::clear_definition() {
  definition_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_definition();
}
inline const ::std::string& ProbeSource::definition() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.ProbeSource.definition)
  return definition_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProbeSource::set_definition(const ::std::string& value) {
  set_has_definition();
  definition_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:KismetDatasource.ProbeSource.definition)
}
inline void ProbeSource::set_definition(const char* value) {
  set_has_definition();
  definition_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:KismetDatasource.ProbeSource.definition)
}
inline void ProbeSource::set_definition(const char* value, size_t size) {
  set_has_definition();
  definition_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:KismetDatasource.ProbeSource.definition)
}
inline ::std::string* ProbeSource::mutable_definition() {
  set_has_definition();
  // @@protoc_insertion_point(field_mutable:KismetDatasource.ProbeSource.definition)
  return definition_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProbeSource::release_definition() {
  // @@protoc_insertion_point(field_release:KismetDatasource.ProbeSource.definition)
  clear_has_definition();
  return definition_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProbeSource::set_allocated_definition(::std::string* definition) {
  if (definition != NULL) {
    set_has_definition();
  } else {
    clear_has_definition();
  }
  definition_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), definition);
  // @@protoc_insertion_point(field_set_allocated:KismetDatasource.ProbeSource.definition)
}

// -------------------------------------------------------------------

// ProbeSourceReport

// required .KismetDatasource.SubSuccess success = 1;
inline bool ProbeSourceReport::has_success() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProbeSourceReport::set_has_success() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProbeSourceReport::clear_has_success() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProbeSourceReport::clear_success() {
  if (success_ != NULL) success_->::KismetDatasource::SubSuccess::Clear();
  clear_has_success();
}
inline const ::KismetDatasource::SubSuccess& ProbeSourceReport::success() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.ProbeSourceReport.success)
  return success_ != NULL ? *success_ : *default_instance_->success_;
}
inline ::KismetDatasource::SubSuccess* ProbeSourceReport::mutable_success() {
  set_has_success();
  if (success_ == NULL) {
    success_ = new ::KismetDatasource::SubSuccess;
  }
  // @@protoc_insertion_point(field_mutable:KismetDatasource.ProbeSourceReport.success)
  return success_;
}
inline ::KismetDatasource::SubSuccess* ProbeSourceReport::release_success() {
  // @@protoc_insertion_point(field_release:KismetDatasource.ProbeSourceReport.success)
  clear_has_success();
  ::KismetDatasource::SubSuccess* temp = success_;
  success_ = NULL;
  return temp;
}
inline void ProbeSourceReport::set_allocated_success(::KismetDatasource::SubSuccess* success) {
  delete success_;
  success_ = success;
  if (success) {
    set_has_success();
  } else {
    clear_has_success();
  }
  // @@protoc_insertion_point(field_set_allocated:KismetDatasource.ProbeSourceReport.success)
}

// optional .KismetDatasource.SubMsgbus message = 2;
inline bool ProbeSourceReport::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProbeSourceReport::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProbeSourceReport::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProbeSourceReport::clear_message() {
  if (message_ != NULL) message_->::KismetDatasource::SubMsgbus::Clear();
  clear_has_message();
}
inline const ::KismetDatasource::SubMsgbus& ProbeSourceReport::message() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.ProbeSourceReport.message)
  return message_ != NULL ? *message_ : *default_instance_->message_;
}
inline ::KismetDatasource::SubMsgbus* ProbeSourceReport::mutable_message() {
  set_has_message();
  if (message_ == NULL) {
    message_ = new ::KismetDatasource::SubMsgbus;
  }
  // @@protoc_insertion_point(field_mutable:KismetDatasource.ProbeSourceReport.message)
  return message_;
}
inline ::KismetDatasource::SubMsgbus* ProbeSourceReport::release_message() {
  // @@protoc_insertion_point(field_release:KismetDatasource.ProbeSourceReport.message)
  clear_has_message();
  ::KismetDatasource::SubMsgbus* temp = message_;
  message_ = NULL;
  return temp;
}
inline void ProbeSourceReport::set_allocated_message(::KismetDatasource::SubMsgbus* message) {
  delete message_;
  message_ = message;
  if (message) {
    set_has_message();
  } else {
    clear_has_message();
  }
  // @@protoc_insertion_point(field_set_allocated:KismetDatasource.ProbeSourceReport.message)
}

// optional .KismetDatasource.SubChannels channels = 3;
inline bool ProbeSourceReport::has_channels() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProbeSourceReport::set_has_channels() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProbeSourceReport::clear_has_channels() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProbeSourceReport::clear_channels() {
  if (channels_ != NULL) channels_->::KismetDatasource::SubChannels::Clear();
  clear_has_channels();
}
inline const ::KismetDatasource::SubChannels& ProbeSourceReport::channels() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.ProbeSourceReport.channels)
  return channels_ != NULL ? *channels_ : *default_instance_->channels_;
}
inline ::KismetDatasource::SubChannels* ProbeSourceReport::mutable_channels() {
  set_has_channels();
  if (channels_ == NULL) {
    channels_ = new ::KismetDatasource::SubChannels;
  }
  // @@protoc_insertion_point(field_mutable:KismetDatasource.ProbeSourceReport.channels)
  return channels_;
}
inline ::KismetDatasource::SubChannels* ProbeSourceReport::release_channels() {
  // @@protoc_insertion_point(field_release:KismetDatasource.ProbeSourceReport.channels)
  clear_has_channels();
  ::KismetDatasource::SubChannels* temp = channels_;
  channels_ = NULL;
  return temp;
}
inline void ProbeSourceReport::set_allocated_channels(::KismetDatasource::SubChannels* channels) {
  delete channels_;
  channels_ = channels;
  if (channels) {
    set_has_channels();
  } else {
    clear_has_channels();
  }
  // @@protoc_insertion_point(field_set_allocated:KismetDatasource.ProbeSourceReport.channels)
}

// optional .KismetDatasource.SubChanset chanset = 4;
inline bool ProbeSourceReport::has_chanset() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProbeSourceReport::set_has_chanset() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProbeSourceReport::clear_has_chanset() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProbeSourceReport::clear_chanset() {
  if (chanset_ != NULL) chanset_->::KismetDatasource::SubChanset::Clear();
  clear_has_chanset();
}
inline const ::KismetDatasource::SubChanset& ProbeSourceReport::chanset() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.ProbeSourceReport.chanset)
  return chanset_ != NULL ? *chanset_ : *default_instance_->chanset_;
}
inline ::KismetDatasource::SubChanset* ProbeSourceReport::mutable_chanset() {
  set_has_chanset();
  if (chanset_ == NULL) {
    chanset_ = new ::KismetDatasource::SubChanset;
  }
  // @@protoc_insertion_point(field_mutable:KismetDatasource.ProbeSourceReport.chanset)
  return chanset_;
}
inline ::KismetDatasource::SubChanset* ProbeSourceReport::release_chanset() {
  // @@protoc_insertion_point(field_release:KismetDatasource.ProbeSourceReport.chanset)
  clear_has_chanset();
  ::KismetDatasource::SubChanset* temp = chanset_;
  chanset_ = NULL;
  return temp;
}
inline void ProbeSourceReport::set_allocated_chanset(::KismetDatasource::SubChanset* chanset) {
  delete chanset_;
  chanset_ = chanset;
  if (chanset) {
    set_has_chanset();
  } else {
    clear_has_chanset();
  }
  // @@protoc_insertion_point(field_set_allocated:KismetDatasource.ProbeSourceReport.chanset)
}

// optional .KismetDatasource.SubSpecset specset = 5;
inline bool ProbeSourceReport::has_specset() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ProbeSourceReport::set_has_specset() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ProbeSourceReport::clear_has_specset() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ProbeSourceReport::clear_specset() {
  if (specset_ != NULL) specset_->::KismetDatasource::SubSpecset::Clear();
  clear_has_specset();
}
inline const ::KismetDatasource::SubSpecset& ProbeSourceReport::specset() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.ProbeSourceReport.specset)
  return specset_ != NULL ? *specset_ : *default_instance_->specset_;
}
inline ::KismetDatasource::SubSpecset* ProbeSourceReport::mutable_specset() {
  set_has_specset();
  if (specset_ == NULL) {
    specset_ = new ::KismetDatasource::SubSpecset;
  }
  // @@protoc_insertion_point(field_mutable:KismetDatasource.ProbeSourceReport.specset)
  return specset_;
}
inline ::KismetDatasource::SubSpecset* ProbeSourceReport::release_specset() {
  // @@protoc_insertion_point(field_release:KismetDatasource.ProbeSourceReport.specset)
  clear_has_specset();
  ::KismetDatasource::SubSpecset* temp = specset_;
  specset_ = NULL;
  return temp;
}
inline void ProbeSourceReport::set_allocated_specset(::KismetDatasource::SubSpecset* specset) {
  delete specset_;
  specset_ = specset;
  if (specset) {
    set_has_specset();
  } else {
    clear_has_specset();
  }
  // @@protoc_insertion_point(field_set_allocated:KismetDatasource.ProbeSourceReport.specset)
}

// optional string hardware = 6;
inline bool ProbeSourceReport::has_hardware() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ProbeSourceReport::set_has_hardware() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ProbeSourceReport::clear_has_hardware() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ProbeSourceReport::clear_hardware() {
  hardware_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hardware();
}
inline const ::std::string& ProbeSourceReport::hardware() const {
  // @@protoc_insertion_point(field_get:KismetDatasource.ProbeSourceReport.hardware)
  return hardware_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProbeSourceReport::set_hardware(const ::std::string& value) {
  set_has_hardware();
  hardware_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:KismetDatasource.ProbeSourceReport.hardware)
}
inline void ProbeSourceReport::set_hardware(const char* value) {
  set_has_hardware();
  hardware_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:KismetDatasource.ProbeSourceReport.hardware)
}
inline void ProbeSourceReport::set_hardware(const char* value, size_t size) {
  set_has_hardware();
  hardware_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:KismetDatasource.ProbeSourceReport.hardware)
}
inline ::std::string* ProbeSourceReport::mutable_hardware() {
  set_has_hardware();
  // @@protoc_insertion_point(field_mutable:KismetDatasource.ProbeSourceReport.hardware)
  return hardware_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProbeSourceReport::release_hardware() {
  // @@protoc_insertion_point(field_release:KismetDatasource.ProbeSourceReport.hardware)
  clear_has_hardware();
  return hardware_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProbeSourceReport::set_allocated_hardware(::std::string* hardware) {
  if (hardware != NULL) {
    set_has_hardware();
  } else {
    clear_has_hardware();
  }
  hardware_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hardware);
  // @@protoc_insertion_point(field_set_allocated:KismetDatasource.ProbeSourceReport.hardware)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace KismetDatasource

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::KismetDatasource::SubMsgbus_MessageType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::KismetDatasource::SubMsgbus_MessageType>() {
  return ::KismetDatasource::SubMsgbus_MessageType_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_datasource_2eproto__INCLUDED
