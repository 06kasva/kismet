Kismet Newcore

The existing Kismet codebase has grown from its beginnings.  While it works,
generally, it has been grown, not designed, and has numerous quirks and 
poorly implemented parts.

The newcore branch of Kismet is a nearly complete rewrite of the entire
codebase, focusing on design, maintainablity, and modular code.  A major
goal of the rewrite is to allow a plugin architecture, which is well 
under way.

After nearly a year of development, the newcore codebase is finally functional.
Now that it is standing on its own, development will go much more quickly.
Major modules are still missing from the code, however they are being filled
in rapidly.  Like any major rewrite, there will be growing pains as platform
or interface-specific components are put back into action.

Once newcore has reached an equivalent level of functionality with the 
stable code branch, it will replace the existing Kismet codebase.

DEVELOPING IN NEWCORE

Some disjointed comments about the design...

Everything in newcore is (primarily) a fully self-contained module.  The module
can do its own config file parsing, command line argument parsing, etc.
Modules can (and should) register their own packet components and their
own network protocols.

The core packet model is the "packet chain".  Packets are created and then
injected into the chain.  As they pass through the chain, new components
can be added to them;  For example, most packets will have a raw link data
component, a 802.11 raw component, a parsed 802.11 information block, and
a gps data component.

The base event loop is driven by the core single select() and the timetracker
event module.  All modules which need to participate in the select() event loop
should be derived from the Pollable class and register themselves with the
global polling system.

Every module should connect to the GlobalRegistry.  This is a large 
super-class of variables which takes the place of a messy pile of globals.
Non-mainline modules can register new tracked components with the global
registry to share between classes.  The globalreg functions as the main
tracking system for injecting messages, accessing runtime configuration,
and communicating with other modules.

The messagebus is a common system for sending information to the user.  A text
string injected into the messagebus carries flags to indicate the type of
message.  Subscribers to the messagebus can then display the message, log it
to a file, queue it for output to stdout on exit, etc.

EXAMPLES

Currently one of the best examples of the newcore design is the GPS client
module, gpsdclient.[h|cc].  It excercises many of the new methods.

NETWORK TRACKING

Network tracking is basically the same as it was before, however some things
have been made more explicit:

* All networks now have at least one client.  The network itself is a client
  of itself.  This handles many weird discrepencies in the old model about
  how client data was different from network data, how IPs were calculated, 
  etc.

* Network totals are still tracked realtime.  This is much cheaper than
  iterating over the clients in a network shell.

* Network numbers must be recalculated when moving a client to another network.
  subtract all the totals of client1 from net1 and add them to net2

* The kisclient will be responsible for moving clients between networks on
  the client end of things, but doesn't need to be smart enough to move
  packet totals -- the new packet total for the network shell will be pushed
  in the NETWORK update.

PLUGIN ARCHITECTURE

Plugins are scary things.  They can do basically anything to you.  Be careful
what you load!

Root plugins:  Plugins that load as root before the privdrop must be in
               the system plugin directory (/install-prefix/lib/kismet/).
               That directory must be owned by root:root.  The directory
               must not be writeable by anyone else (mode 755 or more
               restrictive).  The plugin must be owned by root:root, and
               not be writeable by anyone else (755 or more restrictive).
               Finally, the plugin MUST be specified in the kismet.conf
               config on a 'rootplugin=foo.so' line.

User plugins:  Anything found in a plugin directory after the privdrop,
               that wasn't loaded as root, is probed and loaded.
               Plugin directories are '/install-prefix/lib/kismet/' and
               'userconfig/plugins/' (typically ~/.kismet/plugins).

Security mentality:  Root plugins are super-dangerous.  We can't keep
the user from loading one, but we can make sure that other users on the
system can't corrupt it, and we can make sure only ones actively approved
are loaded during startup.

Plugins must be enabled in the config file!

Plugins are expected to have 1 exported extern "C" function, and respond
to register/unregister events appropriately.  Look at the example plugin
for more info.

The plugin registrant is called many times during load, until it returns a
value that indicates total failure or success.  A plugin can look at the
globalregistry pointers for standard system components to determine if the
plugin is able to load yet.  If it isn't, it should return 0 and it will be
asked again later.

Plugins are responsible for adding their own callbacks to the system
components, and for removing them cleanly on request.  Plugins have
access to any system component that Kismet itself can access, which gives
them extroadinary power.

Documentation on the system components and APIs will be forthcoming.

